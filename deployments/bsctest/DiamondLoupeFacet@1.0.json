{
  "address": "0x6e8364f916b521a8eE3E5EFe7EC64eD5E3f39968",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IForwarderRegistry",
          "name": "forwarderRegistry",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "functionSelector",
          "type": "bytes4"
        }
      ],
      "name": "facetAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "facetAddress_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facetAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "facetAddresses_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "facet",
          "type": "address"
        }
      ],
      "name": "facetFunctionSelectors",
      "outputs": [
        {
          "internalType": "bytes4[]",
          "name": "facetFunctionSelectors_",
          "type": "bytes4[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facets",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facet",
              "type": "address"
            },
            {
              "internalType": "bytes4[]",
              "name": "selectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondLoupe.Facet[]",
          "name": "facets_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initDiamondLoupeStorage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x878c8c65735e84d0a43f4343e8f28b2ebfb084d96114a0fe1f249925c3fccfd7",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xF7e30493A9018Bd8f364ba0E83E3BD4DD5d6bB2b",
    "contractAddress": null,
    "transactionIndex": 6,
    "gasUsed": "899124",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0fe9de3d27ea7ce4113b5b53997c638f4db914c3c290340691dbc9a39c6c1933",
    "transactionHash": "0x878c8c65735e84d0a43f4343e8f28b2ebfb084d96114a0fe1f249925c3fccfd7",
    "logs": [],
    "blockNumber": 28608464,
    "cumulativeGasUsed": "1398229",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x3f547F87251710F70109Ae0409d461b270709693"
  ],
  "numDeployments": 1,
  "solcInputHash": "a6ab94751dde68b4d6125ac6f179d1ce",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IForwarderRegistry\",\"name\":\"forwarderRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"facetFunctionSelectors_\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDiamondLoupeStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"See https://eips.ethereum.org/EIPS/eip-2535Note: This facet depends on {ProxyAdminFacet} and {InterfaceDetectionFacet}.\",\"kind\":\"dev\",\"methods\":{\"facetAddress(bytes4)\":{\"params\":{\"functionSelector\":\"The function selector.\"},\"returns\":{\"facetAddress_\":\"The facet address that supports `functionSelector`, or the zero address if the facet is not found.\"}},\"facetAddresses()\":{\"returns\":{\"facetAddresses_\":\"The facet addresses used by the diamond.\"}},\"facetFunctionSelectors(address)\":{\"params\":{\"facetAddress\":\"The facet address.\"},\"returns\":{\"facetFunctionSelectors_\":\"The function selectors supported by `facet`.\"}},\"facets()\":{\"returns\":{\"facets_\":\"The facet addresses used by the diamond and their function selectors.\"}},\"initDiamondLoupeStorage()\":{\"details\":\"Reverts if the sender is not the proxy admin.\"}},\"title\":\"Diamond Loupe (facet version).\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"facetAddress(bytes4)\":{\"notice\":\"Gets the facet address that supports a given function selector.\"},\"facetAddresses()\":{\"notice\":\"Get all the facet addresses used by the diamond.\"},\"facetFunctionSelectors(address)\":{\"notice\":\"Gets all the function selectors supported by a facet.\"},\"facets()\":{\"notice\":\"Gets all the facet addresses used by the diamond and their function selectors.\"},\"initDiamondLoupeStorage()\":{\"notice\":\"Marks the following ERC165 interface(s) as supported: DiamondLoupe.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/diamond/facets/DiamondLoupeFacet.sol\":\"DiamondLoupeFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":99999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c50c54bf02740ebd122ff06832546cb5fa84486d52695a9ccfd11666e0c81d\",\"license\":\"MIT\"},\"contracts/diamond/facets/DiamondLoupeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\npragma experimental ABIEncoderV2;\\n\\nimport {IForwarderRegistry} from \\\"./../../metatx/interfaces/IForwarderRegistry.sol\\\";\\nimport {IDiamondLoupe} from \\\"./../interfaces/IDiamondLoupe.sol\\\";\\nimport {DiamondStorage} from \\\"./../libraries/DiamondStorage.sol\\\";\\nimport {ProxyAdminStorage} from \\\"./../../proxy/libraries/ProxyAdminStorage.sol\\\";\\nimport {ForwarderRegistryContextBase} from \\\"./../../metatx/base/ForwarderRegistryContextBase.sol\\\";\\n\\n/// @title Diamond Loupe (facet version).\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2535\\n/// @dev Note: This facet depends on {ProxyAdminFacet} and {InterfaceDetectionFacet}.\\ncontract DiamondLoupeFacet is IDiamondLoupe, ForwarderRegistryContextBase {\\n    using ProxyAdminStorage for ProxyAdminStorage.Layout;\\n    using DiamondStorage for DiamondStorage.Layout;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) ForwarderRegistryContextBase(forwarderRegistry) {}\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: DiamondLoupe.\\n    /// @dev Reverts if the sender is not the proxy admin.\\n    function initDiamondLoupeStorage() external {\\n        ProxyAdminStorage.layout().enforceIsProxyAdmin(_msgSender());\\n        DiamondStorage.initDiamondLoupe();\\n    }\\n\\n    /// @inheritdoc IDiamondLoupe\\n    function facets() external view override returns (IDiamondLoupe.Facet[] memory facets_) {\\n        facets_ = DiamondStorage.layout().facets();\\n    }\\n\\n    /// @inheritdoc IDiamondLoupe\\n    function facetFunctionSelectors(address facet) external view override returns (bytes4[] memory facetFunctionSelectors_) {\\n        facetFunctionSelectors_ = DiamondStorage.layout().facetFunctionSelectors(facet);\\n    }\\n\\n    /// @inheritdoc IDiamondLoupe\\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\\n        facetAddresses_ = DiamondStorage.layout().facetAddresses();\\n    }\\n\\n    /// @inheritdoc IDiamondLoupe\\n    function facetAddress(bytes4 functionSelector) external view override returns (address facetAddress_) {\\n        facetAddress_ = DiamondStorage.layout().facetAddress(functionSelector);\\n    }\\n}\\n\",\"keccak256\":\"0xdfc8958874a6bde1054ee09e79c395ed76541693a58753e7d6dc9630343592d7\",\"license\":\"MIT\"},\"contracts/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\npragma experimental ABIEncoderV2;\\n\\nimport {IDiamondCutCommon} from \\\"./IDiamondCutCommon.sol\\\";\\n\\n/// @title ERC2535 Diamond Standard, Diamond Cut.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2535\\n/// @dev Note: the ERC-165 identifier for this interface is 0x1f931c1c\\ninterface IDiamondCut is IDiamondCutCommon {\\n    /// @notice Add/replace/remove facet functions and optionally execute a function with delegatecall.\\n    /// @dev Emits a {DiamondCut} event.\\n    /// @param cuts The list of facet addresses, actions and function selectors to apply to the diamond.\\n    /// @param target The address of the contract to execute `data` on.\\n    /// @param data The encoded function call to execute on `target`.\\n    function diamondCut(FacetCut[] calldata cuts, address target, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0x5c2b4fde495d2572c1c857513fbc47ebc246665718270b624b4f431122e19057\",\"license\":\"MIT\"},\"contracts/diamond/interfaces/IDiamondCutBatchInit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\npragma experimental ABIEncoderV2;\\n\\nimport {IDiamondCutCommon} from \\\"./IDiamondCutCommon.sol\\\";\\n\\n/// @title ERCXXX Diamond Standard, Diamond Cut Batch Init extension.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-XXXX\\n/// @dev Note: the ERC-165 identifier for this interface is 0xb2afc5b5\\ninterface IDiamondCutBatchInit is IDiamondCutCommon {\\n    /// @notice Add/replace/remove facet functions and execute a batch of functions with delegatecall.\\n    /// @dev Emits a {DiamondCut} event.\\n    /// @param cuts The list of facet addresses, actions and function selectors to apply to the diamond.\\n    /// @param initializations The list of addresses and encoded function calls to execute with delegatecall.\\n    function diamondCut(FacetCut[] calldata cuts, Initialization[] calldata initializations) external;\\n}\\n\",\"keccak256\":\"0x9ee36307c69cd5e4a178bff0f4f20103021463e3ad4a484dc59ae04a741ef00b\",\"license\":\"MIT\"},\"contracts/diamond/interfaces/IDiamondCutCommon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\npragma experimental ABIEncoderV2;\\n\\ninterface IDiamondCutCommon {\\n    enum FacetCutAction {\\n        ADD,\\n        REPLACE,\\n        REMOVE\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facet;\\n        FacetCutAction action;\\n        bytes4[] selectors;\\n    }\\n\\n    struct Initialization {\\n        address target;\\n        bytes data;\\n    }\\n\\n    /// @notice Emitted when at least a cut action is operated on the diamond.\\n    /// @param cuts The list of facet addresses, actions and function selectors applied to the diamond.\\n    /// @param target The address of the contract where `data` was executed.\\n    /// @param data The encoded function call executed on `target`.\\n    event DiamondCut(FacetCut[] cuts, address target, bytes data);\\n}\\n\",\"keccak256\":\"0x3efbb13f77b63b4b3dfb9260b28754256666ed0c3073db5e68b738ab9e9dd536\",\"license\":\"MIT\"},\"contracts/diamond/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\npragma experimental ABIEncoderV2;\\n\\n/// @title ERC2535 Diamond Standard, Diamond Loupe.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2535\\n/// @dev Note: the ERC-165 identifier for this interface is 0x48e2b093\\ninterface IDiamondLoupe {\\n    struct Facet {\\n        address facet;\\n        bytes4[] selectors;\\n    }\\n\\n    /// @notice Gets all the facet addresses used by the diamond and their function selectors.\\n    /// @return diamondFacets The facet addresses used by the diamond and their function selectors.\\n    function facets() external view returns (Facet[] memory diamondFacets);\\n\\n    /// @notice Gets all the function selectors supported by a facet.\\n    /// @param facetAddress The facet address.\\n    /// @return selectors The function selectors supported by `facet`.\\n    function facetFunctionSelectors(address facetAddress) external view returns (bytes4[] memory selectors);\\n\\n    /// @notice Get all the facet addresses used by the diamond.\\n    /// @return diamondFacetsAddresses The facet addresses used by the diamond.\\n    function facetAddresses() external view returns (address[] memory diamondFacetsAddresses);\\n\\n    /// @notice Gets the facet address that supports a given function selector.\\n    /// @param functionSelector The function selector.\\n    /// @return diamondFacetAddress The facet address that supports `functionSelector`, or the zero address if the facet is not found.\\n    function facetAddress(bytes4 functionSelector) external view returns (address diamondFacetAddress);\\n}\\n\",\"keccak256\":\"0x00e4622240e6e3f426e7ffb4aff789c96025b8a8214a6f6abe01e3a3f1de155f\",\"license\":\"MIT\"},\"contracts/diamond/libraries/DiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\npragma experimental ABIEncoderV2;\\n\\nimport {IDiamondCutCommon} from \\\"./../interfaces/IDiamondCutCommon.sol\\\";\\nimport {IDiamondCut} from \\\"./../interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondCutBatchInit} from \\\"./../interfaces/IDiamondCutBatchInit.sol\\\";\\nimport {IDiamondLoupe} from \\\"./../interfaces/IDiamondLoupe.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./../../introspection/libraries/InterfaceDetectionStorage.sol\\\";\\n\\n/// @dev derived from https://github.com/mudgen/diamond-2 (MIT licence) and https://github.com/solidstate-network/solidstate-solidity (MIT licence)\\nlibrary DiamondStorage {\\n    using Address for address;\\n    using DiamondStorage for DiamondStorage.Layout;\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n\\n    struct Layout {\\n        // selector => (facet address, selector slot position)\\n        mapping(bytes4 => bytes32) diamondFacets;\\n        // number of selectors registered in selectorSlots\\n        uint16 selectorCount;\\n        // array of selector slots with 8 selectors per slot\\n        mapping(uint256 => bytes32) selectorSlots;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.Diamond.storage\\\")) - 1);\\n\\n    bytes32 internal constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 internal constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    event DiamondCut(IDiamondCutCommon.FacetCut[] cuts, address target, bytes data);\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: DiamondCut, DiamondCutBatchInit.\\n    function initDiamondCut() internal {\\n        InterfaceDetectionStorage.Layout storage interfaceDetectionLayout = InterfaceDetectionStorage.layout();\\n        interfaceDetectionLayout.setSupportedInterface(type(IDiamondCut).interfaceId, true);\\n        interfaceDetectionLayout.setSupportedInterface(type(IDiamondCutBatchInit).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: DiamondLoupe.\\n    function initDiamondLoupe() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IDiamondLoupe).interfaceId, true);\\n    }\\n\\n    function diamondCut(Layout storage s, IDiamondCutCommon.FacetCut[] memory cuts, address target, bytes memory data) internal {\\n        cutFacets(s, cuts);\\n        emit DiamondCut(cuts, target, data);\\n        initializationCall(target, data);\\n    }\\n\\n    function diamondCut(\\n        Layout storage s,\\n        IDiamondCutCommon.FacetCut[] memory cuts,\\n        IDiamondCutCommon.Initialization[] memory initializations\\n    ) internal {\\n        unchecked {\\n            s.cutFacets(cuts);\\n            emit DiamondCut(cuts, address(0), \\\"\\\");\\n            uint256 length = initializations.length;\\n            for (uint256 i; i != length; ++i) {\\n                initializationCall(initializations[i].target, initializations[i].data);\\n            }\\n        }\\n    }\\n\\n    function cutFacets(Layout storage s, IDiamondCutCommon.FacetCut[] memory facetCuts) internal {\\n        unchecked {\\n            uint256 originalSelectorCount = s.selectorCount;\\n            uint256 selectorCount = originalSelectorCount;\\n            bytes32 selectorSlot;\\n\\n            // Check if last selector slot is not full\\n            if (selectorCount & 7 > 0) {\\n                // get last selectorSlot\\n                selectorSlot = s.selectorSlots[selectorCount >> 3];\\n            }\\n\\n            uint256 length = facetCuts.length;\\n            for (uint256 i; i != length; ++i) {\\n                IDiamondCutCommon.FacetCut memory facetCut = facetCuts[i];\\n                IDiamondCutCommon.FacetCutAction action = facetCut.action;\\n\\n                require(facetCut.selectors.length != 0, \\\"Diamond: no function selectors\\\");\\n\\n                if (action == IDiamondCutCommon.FacetCutAction.ADD) {\\n                    (selectorCount, selectorSlot) = s.addFacetSelectors(selectorCount, selectorSlot, facetCut);\\n                } else if (action == IDiamondCutCommon.FacetCutAction.REPLACE) {\\n                    s.replaceFacetSelectors(facetCut);\\n                } else {\\n                    (selectorCount, selectorSlot) = s.removeFacetSelectors(selectorCount, selectorSlot, facetCut);\\n                }\\n            }\\n\\n            if (selectorCount != originalSelectorCount) {\\n                s.selectorCount = uint16(selectorCount);\\n            }\\n\\n            // If last selector slot is not full\\n            if (selectorCount & 7 > 0) {\\n                s.selectorSlots[selectorCount >> 3] = selectorSlot;\\n            }\\n        }\\n    }\\n\\n    function addFacetSelectors(\\n        Layout storage s,\\n        uint256 selectorCount,\\n        bytes32 selectorSlot,\\n        IDiamondCutCommon.FacetCut memory facetCut\\n    ) internal returns (uint256, bytes32) {\\n        unchecked {\\n            if (facetCut.facet != address(this)) {\\n                // allows immutable functions to be added from a constructor\\n                require(facetCut.facet.isContract(), \\\"Diamond: facet has no code\\\"); // reverts if executed from a constructor\\n            }\\n\\n            uint256 length = facetCut.selectors.length;\\n            for (uint256 i; i != length; ++i) {\\n                bytes4 selector = facetCut.selectors[i];\\n                bytes32 oldFacet = s.diamondFacets[selector];\\n\\n                require(address(bytes20(oldFacet)) == address(0), \\\"Diamond: selector already added\\\");\\n\\n                // add facet for selector\\n                s.diamondFacets[selector] = bytes20(facetCut.facet) | bytes32(selectorCount);\\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\\n\\n                // clear selector position in slot and add selector\\n                selectorSlot = (selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    s.selectorSlots[selectorCount >> 3] = selectorSlot;\\n                    selectorSlot = 0;\\n                }\\n\\n                ++selectorCount;\\n            }\\n\\n            return (selectorCount, selectorSlot);\\n        }\\n    }\\n\\n    function removeFacetSelectors(\\n        Layout storage s,\\n        uint256 selectorCount,\\n        bytes32 selectorSlot,\\n        IDiamondCutCommon.FacetCut memory facetCut\\n    ) internal returns (uint256, bytes32) {\\n        unchecked {\\n            require(facetCut.facet == address(0), \\\"Diamond: non-zero address facet\\\");\\n\\n            uint256 selectorSlotCount = selectorCount >> 3;\\n            uint256 selectorInSlotIndex = selectorCount & 7;\\n\\n            for (uint256 i; i != facetCut.selectors.length; ++i) {\\n                bytes4 selector = facetCut.selectors[i];\\n                bytes32 oldFacet = s.diamondFacets[selector];\\n\\n                require(address(bytes20(oldFacet)) != address(0), \\\"Diamond: selector not found\\\");\\n                require(address(bytes20(oldFacet)) != address(this), \\\"Diamond: immutable function\\\");\\n\\n                if (selectorSlot == 0) {\\n                    selectorSlotCount--;\\n                    selectorSlot = s.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n\\n                // adding a block here prevents stack too deep error\\n                {\\n                    // replace selector with last selector in l.facets\\n                    lastSelector = bytes4(selectorSlot << (selectorInSlotIndex << 5));\\n\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        s.diamondFacets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(s.diamondFacets[lastSelector]);\\n                    }\\n\\n                    delete s.diamondFacets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = s.selectorSlots[oldSelectorsSlotCount];\\n\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                    // update storage with the modified slot\\n                    s.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    selectorSlot =\\n                        (selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n\\n                if (selectorInSlotIndex == 0) {\\n                    delete s.selectorSlots[selectorSlotCount];\\n                    selectorSlot = 0;\\n                }\\n            }\\n\\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\\n\\n            return (selectorCount, selectorSlot);\\n        }\\n    }\\n\\n    function replaceFacetSelectors(Layout storage s, IDiamondCutCommon.FacetCut memory facetCut) internal {\\n        unchecked {\\n            require(facetCut.facet.isContract(), \\\"Diamond: facet has no code\\\");\\n\\n            uint256 length = facetCut.selectors.length;\\n            for (uint256 i; i != length; ++i) {\\n                bytes4 selector = facetCut.selectors[i];\\n                bytes32 oldFacet = s.diamondFacets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n\\n                require(oldFacetAddress != address(0), \\\"Diamond: selector not found\\\");\\n                require(oldFacetAddress != address(this), \\\"Diamond: immutable function\\\");\\n                require(oldFacetAddress != facetCut.facet, \\\"Diamond: identical function\\\");\\n\\n                // replace old facet address\\n                s.diamondFacets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(facetCut.facet);\\n            }\\n        }\\n    }\\n\\n    function initializationCall(address target, bytes memory data) internal {\\n        if (target == address(0)) {\\n            require(data.length == 0, \\\"Diamond: data is not empty\\\");\\n        } else {\\n            require(data.length != 0, \\\"Diamond: data is empty\\\");\\n            if (target != address(this)) {\\n                require(target.isContract(), \\\"Diamond: target has no code\\\");\\n            }\\n\\n            (bool success, bytes memory returndata) = target.delegatecall(data);\\n            if (!success) {\\n                uint256 returndataLength = returndata.length;\\n                if (returndataLength != 0) {\\n                    assembly {\\n                        revert(add(32, returndata), returndataLength)\\n                    }\\n                } else {\\n                    revert(\\\"Diamond: init call reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function facets(Layout storage s) internal view returns (IDiamondLoupe.Facet[] memory diamondFacets) {\\n        unchecked {\\n            uint16 selectorCount = s.selectorCount;\\n            diamondFacets = new IDiamondLoupe.Facet[](selectorCount);\\n\\n            uint256[] memory numFacetSelectors = new uint256[](selectorCount);\\n            uint256 numFacets;\\n            uint256 selectorIndex;\\n\\n            // loop through function selectors\\n            for (uint256 slotIndex; selectorIndex < selectorCount; ++slotIndex) {\\n                bytes32 slot = s.selectorSlots[slotIndex];\\n\\n                for (uint256 selectorSlotIndex; selectorSlotIndex != 8; ++selectorSlotIndex) {\\n                    ++selectorIndex;\\n\\n                    if (selectorIndex > selectorCount) {\\n                        break;\\n                    }\\n\\n                    bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n                    address facet = address(bytes20(s.diamondFacets[selector]));\\n\\n                    bool continueLoop;\\n\\n                    for (uint256 facetIndex; facetIndex != numFacets; ++facetIndex) {\\n                        if (diamondFacets[facetIndex].facet == facet) {\\n                            diamondFacets[facetIndex].selectors[numFacetSelectors[facetIndex]] = selector;\\n                            ++numFacetSelectors[facetIndex];\\n                            continueLoop = true;\\n                            break;\\n                        }\\n                    }\\n\\n                    if (continueLoop) {\\n                        continue;\\n                    }\\n\\n                    diamondFacets[numFacets].facet = facet;\\n                    diamondFacets[numFacets].selectors = new bytes4[](selectorCount);\\n                    diamondFacets[numFacets].selectors[0] = selector;\\n                    numFacetSelectors[numFacets] = 1;\\n                    ++numFacets;\\n                }\\n            }\\n\\n            for (uint256 facetIndex; facetIndex != numFacets; ++facetIndex) {\\n                uint256 numSelectors = numFacetSelectors[facetIndex];\\n                bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\\n\\n                // setting the number of selectors\\n                assembly {\\n                    mstore(selectors, numSelectors)\\n                }\\n            }\\n\\n            // setting the number of facets\\n            assembly {\\n                mstore(diamondFacets, numFacets)\\n            }\\n        }\\n    }\\n\\n    function facetFunctionSelectors(Layout storage s, address facet) internal view returns (bytes4[] memory selectors) {\\n        unchecked {\\n            uint16 selectorCount = s.selectorCount;\\n            selectors = new bytes4[](selectorCount);\\n\\n            uint256 numSelectors;\\n            uint256 selectorIndex;\\n\\n            // loop through function selectors\\n            for (uint256 slotIndex; selectorIndex < selectorCount; ++slotIndex) {\\n                bytes32 slot = s.selectorSlots[slotIndex];\\n\\n                for (uint256 selectorSlotIndex; selectorSlotIndex != 8; ++selectorSlotIndex) {\\n                    ++selectorIndex;\\n\\n                    if (selectorIndex > selectorCount) {\\n                        break;\\n                    }\\n\\n                    bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n\\n                    if (facet == address(bytes20(s.diamondFacets[selector]))) {\\n                        selectors[numSelectors] = selector;\\n                        ++numSelectors;\\n                    }\\n                }\\n            }\\n\\n            // set the number of selectors in the array\\n            assembly {\\n                mstore(selectors, numSelectors)\\n            }\\n        }\\n    }\\n\\n    function facetAddresses(Layout storage s) internal view returns (address[] memory addresses) {\\n        unchecked {\\n            uint16 selectorCount = s.selectorCount;\\n            addresses = new address[](selectorCount);\\n            uint256 numFacets;\\n            uint256 selectorIndex;\\n\\n            for (uint256 slotIndex; selectorIndex < selectorCount; ++slotIndex) {\\n                bytes32 slot = s.selectorSlots[slotIndex];\\n\\n                for (uint256 selectorSlotIndex; selectorSlotIndex != 8; ++selectorSlotIndex) {\\n                    ++selectorIndex;\\n\\n                    if (selectorIndex > selectorCount) {\\n                        break;\\n                    }\\n\\n                    bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n                    address facet = address(bytes20(s.diamondFacets[selector]));\\n\\n                    bool continueLoop;\\n\\n                    for (uint256 facetIndex; facetIndex != numFacets; ++facetIndex) {\\n                        if (facet == addresses[facetIndex]) {\\n                            continueLoop = true;\\n                            break;\\n                        }\\n                    }\\n\\n                    if (continueLoop) {\\n                        continue;\\n                    }\\n\\n                    addresses[numFacets] = facet;\\n                    ++numFacets;\\n                }\\n            }\\n\\n            // set the number of facet addresses in the array\\n            assembly {\\n                mstore(addresses, numFacets)\\n            }\\n        }\\n    }\\n\\n    function facetAddress(Layout storage s, bytes4 selector) internal view returns (address facet) {\\n        facet = address(bytes20(s.diamondFacets[selector]));\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfdbbf335939b8e24884d2b2c8358eb3c4029c4230848f99de24ad3127876a0d7\",\"license\":\"MIT\"},\"contracts/introspection/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC165 Interface Detection Standard.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-165.\\n/// @dev Note: The ERC-165 identifier for this interface is 0x01ffc9a7.\\ninterface IERC165 {\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId the interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool supported);\\n}\\n\",\"keccak256\":\"0x200c309a198b4f2d5d09ee3ef155ebdb8d8075e205dab2d973139c7ac01c8785\",\"license\":\"MIT\"},\"contracts/introspection/libraries/InterfaceDetectionStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC165} from \\\"./../interfaces/IERC165.sol\\\";\\n\\nlibrary InterfaceDetectionStorage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.introspection.InterfaceDetection.storage\\\")) - 1);\\n\\n    bytes4 internal constant ILLEGAL_INTERFACE_ID = 0xffffffff;\\n\\n    /// @notice Sets or unsets an ERC165 interface.\\n    /// @dev Reverts if `interfaceId` is `0xffffffff`.\\n    /// @param interfaceId the interface identifier.\\n    /// @param supported True to set the interface, false to unset it.\\n    function setSupportedInterface(Layout storage s, bytes4 interfaceId, bool supported) internal {\\n        require(interfaceId != ILLEGAL_INTERFACE_ID, \\\"InterfaceDetection: wrong value\\\");\\n        s.supportedInterfaces[interfaceId] = supported;\\n    }\\n\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId The interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(Layout storage s, bytes4 interfaceId) internal view returns (bool supported) {\\n        if (interfaceId == ILLEGAL_INTERFACE_ID) {\\n            return false;\\n        }\\n        if (interfaceId == type(IERC165).interfaceId) {\\n            return true;\\n        }\\n        return s.supportedInterfaces[interfaceId];\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa16ca8fae4e72b9e4ba99df2efe41889f330544ac611b65a92b1a358d334fce2\",\"license\":\"MIT\"},\"contracts/metatx/base/ForwarderRegistryContextBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IForwarderRegistry} from \\\"./../interfaces/IForwarderRegistry.sol\\\";\\nimport {ERC2771Calldata} from \\\"./../libraries/ERC2771Calldata.sol\\\";\\n\\n/// @title Meta-Transactions Forwarder Registry Context (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Derived from https://github.com/wighawag/universal-forwarder (MIT licence)\\nabstract contract ForwarderRegistryContextBase {\\n    IForwarderRegistry internal immutable _forwarderRegistry;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) {\\n        _forwarderRegistry = forwarderRegistry;\\n    }\\n\\n    /// @notice Returns the message sender depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgSender() internal view virtual returns (address) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.sender;\\n        }\\n\\n        address sender = ERC2771Calldata.msgSender();\\n\\n        // Return the EIP-2771 calldata-appended sender address if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (msg.sender == address(_forwarderRegistry) || _forwarderRegistry.isApprovedForwarder(sender, msg.sender)) {\\n            return sender;\\n        }\\n\\n        return msg.sender;\\n    }\\n\\n    /// @notice Returns the message data depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.data;\\n        }\\n\\n        // Return the EIP-2771 calldata (minus the appended sender) if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (msg.sender == address(_forwarderRegistry) || _forwarderRegistry.isApprovedForwarder(ERC2771Calldata.msgSender(), msg.sender)) {\\n            return ERC2771Calldata.msgData();\\n        }\\n\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xa2e302ddf63a84a87c669bf722ca3071136c545ab836f4a727e88c74ffbf08e2\",\"license\":\"MIT\"},\"contracts/metatx/interfaces/IForwarderRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title Universal Meta-Transactions Forwarder Registry.\\n/// @dev Derived from https://github.com/wighawag/universal-forwarder (MIT licence)\\ninterface IForwarderRegistry {\\n    /// @notice Checks whether an account is as an approved meta-transaction forwarder for a sender account.\\n    /// @param sender The sender account.\\n    /// @param forwarder The forwarder account.\\n    /// @return isApproved True if `forwarder` is an approved meta-transaction forwarder for `sender`, false otherwise.\\n    function isApprovedForwarder(address sender, address forwarder) external view returns (bool isApproved);\\n}\\n\",\"keccak256\":\"0xe3487e6d79da78bc0ea5b4649ca9cc7a0376800280e3e389a5e70fc7ced74d00\",\"license\":\"MIT\"},\"contracts/metatx/libraries/ERC2771Calldata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @dev Derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT licence)\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2771\\nlibrary ERC2771Calldata {\\n    /// @notice Returns the sender address appended at the end of the calldata, as specified in EIP-2771.\\n    function msgSender() internal pure returns (address sender) {\\n        assembly {\\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n    /// @notice Returns the calldata while omitting the appended sender address, as specified in EIP-2771.\\n    function msgData() internal pure returns (bytes calldata data) {\\n        unchecked {\\n            return msg.data[:msg.data.length - 20];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc0801057ee04e34e7600d05383d0cbd6f62433028e9d597cf30c672540c2bdfc\",\"license\":\"MIT\"},\"contracts/proxy/libraries/ProxyAdminStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {StorageSlot} from \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\nimport {ProxyInitialization} from \\\"./ProxyInitialization.sol\\\";\\n\\nlibrary ProxyAdminStorage {\\n    using ProxyAdminStorage for ProxyAdminStorage.Layout;\\n\\n    struct Layout {\\n        address admin;\\n    }\\n\\n    // bytes32 public constant PROXYADMIN_STORAGE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n    bytes32 internal constant PROXY_INIT_PHASE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin.phase\\\")) - 1);\\n\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /// @notice Initializes the storage with an initial admin (immutable version).\\n    /// @dev Note: This function should be called ONLY in the constructor of an immutable (non-proxied) contract.\\n    /// @dev Reverts if `initialAdmin` is the zero address.\\n    /// @dev Emits an {AdminChanged} event.\\n    /// @param initialAdmin The initial payout wallet.\\n    function constructorInit(Layout storage s, address initialAdmin) internal {\\n        require(initialAdmin != address(0), \\\"ProxyAdmin: no initial admin\\\");\\n        s.admin = initialAdmin;\\n        emit AdminChanged(address(0), initialAdmin);\\n    }\\n\\n    /// @notice Initializes the storage with an initial admin (proxied version).\\n    /// @notice Sets the proxy initialization phase to `1`.\\n    /// @dev Note: This function should be called ONLY in the init function of a proxied contract.\\n    /// @dev Reverts if the proxy initialization phase is set to `1` or above.\\n    /// @dev Reverts if `initialAdmin` is the zero address.\\n    /// @dev Emits an {AdminChanged} event.\\n    /// @param initialAdmin The initial payout wallet.\\n    function proxyInit(Layout storage s, address initialAdmin) internal {\\n        ProxyInitialization.setPhase(PROXY_INIT_PHASE_SLOT, 1);\\n        s.constructorInit(initialAdmin);\\n    }\\n\\n    /// @notice Sets a new proxy admin.\\n    /// @dev Reverts if `sender` is not the proxy admin.\\n    /// @dev Emits an {AdminChanged} event if `newAdmin` is different from the current proxy admin.\\n    /// @param newAdmin The new proxy admin.\\n    function changeProxyAdmin(Layout storage s, address sender, address newAdmin) internal {\\n        address previousAdmin = s.admin;\\n        require(sender == previousAdmin, \\\"ProxyAdmin: not the admin\\\");\\n        if (previousAdmin != newAdmin) {\\n            s.admin = newAdmin;\\n            emit AdminChanged(previousAdmin, newAdmin);\\n        }\\n    }\\n\\n    /// @notice Gets the proxy admin.\\n    /// @return admin The proxy admin\\n    function proxyAdmin(Layout storage s) internal view returns (address admin) {\\n        return s.admin;\\n    }\\n\\n    /// @notice Ensures that an account is the proxy admin.\\n    /// @dev Reverts if `account` is not the proxy admin.\\n    /// @param account The account.\\n    function enforceIsProxyAdmin(Layout storage s, address account) internal view {\\n        require(account == s.admin, \\\"ProxyAdmin: not the admin\\\");\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb2b916964151365f60494fa057f19318a4f917c99e044173ee674e4d3c183000\",\"license\":\"MIT\"},\"contracts/proxy/libraries/ProxyInitialization.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {StorageSlot} from \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n/// @notice Multiple calls protection for storage-modifying proxy initialization functions.\\nlibrary ProxyInitialization {\\n    /// @notice Sets the initialization phase during a storage-modifying proxy initialization function.\\n    /// @dev Reverts if `phase` has been reached already.\\n    /// @param storageSlot the storage slot where `phase` is stored.\\n    /// @param phase the initialization phase.\\n    function setPhase(bytes32 storageSlot, uint256 phase) internal {\\n        StorageSlot.Uint256Slot storage currentVersion = StorageSlot.getUint256Slot(storageSlot);\\n        require(currentVersion.value < phase, \\\"Storage: phase reached\\\");\\n        currentVersion.value = phase;\\n    }\\n}\\n\",\"keccak256\":\"0x15087049c228af4a35975ffcb40747ebceefac58be278a7f2903a9f70c54fa63\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051610fe9380380610fe983398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b608051610f57610092600039600081816101f101526102790152610f576000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c80637a0ed627116100505780637a0ed62714610094578063adfca15e146100a9578063cdffacc6146100c957600080fd5b80634fe5dd791461006c57806352ef6b2c14610076575b600080fd5b610074610101565b005b61007e610124565b60405161008b9190610c76565b60405180910390f35b61009c61013b565b60405161008b9190610d2d565b6100bc6100b7366004610dd5565b61014d565b60405161008b9190610e12565b6100dc6100d7366004610e25565b610167565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161008b565b61011a61010c6101ae565b6101146102f5565b90610323565b6101226103af565b565b60606101366101316103e4565b610412565b905090565b60606101366101486103e4565b6105c7565b60606101618261015b6103e4565b906109eb565b92915050565b6000610161826101756103e4565b907fffffffff00000000000000000000000000000000000000000000000000000000166000908152602091909152604090205460601c90565b6000333214806101be5750601836105b156101c857503390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163314806102e457506040517f8929a8ca00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301523360248301527f00000000000000000000000000000000000000000000000000000000000000001690638929a8ca90604401602060405180830381865afa1580156102c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102e49190610e67565b156102ee57919050565b3391505090565b60008061016160017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104610e89565b815473ffffffffffffffffffffffffffffffffffffffff8281169116146103ab576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f50726f787941646d696e3a206e6f74207468652061646d696e0000000000000060448201526064015b60405180910390fd5b5050565b6101227f48e2b0930000000000000000000000000000000000000000000000000000000060016103dd610b3c565b9190610b6a565b60008061016160017f65d27473a5b05206737961f69a3b7a55316862d7a6ef82b3f5455fe92fab43e3610e89565b600181015460609061ffff168067ffffffffffffffff81111561043757610437610ec3565b604051908082528060200260200182016040528015610460578160200160208202803683370190505b50915060008060005b8361ffff168210156105bd576000818152600287016020526040812054905b806008146105b3578360010193508561ffff1684116105b357600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208a9052604081205460601c90805b888114610545578a81815181106104fa576104fa610ef2565b602002602001015173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361053d5760019150610545565b6001016104e1565b508015610554575050506105ab565b818a898151811061056757610567610ef2565b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508760010197505050505b600101610488565b5050600101610469565b5050825250919050565b600181015460609061ffff168067ffffffffffffffff8111156105ec576105ec610ec3565b60405190808252806020026020018201604052801561063257816020015b60408051808201909152600081526060602082015281526020019060019003908161060a5790505b50915060008161ffff1667ffffffffffffffff81111561065457610654610ec3565b60405190808252806020026020018201604052801561067d578160200160208202803683370190505b50905060008060005b8461ffff16821015610987576000818152600288016020526040812054905b8060081461097d578360010193508661ffff16841161097d57600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208b9052604081205460601c90805b88811461081f578273ffffffffffffffffffffffffffffffffffffffff168c828151811061072e5761072e610ef2565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff160361081757838c828151811061076857610768610ef2565b6020026020010151602001518b838151811061078657610786610ef2565b60200260200101518151811061079e5761079e610ef2565b60200260200101907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815250508981815181106107fc576107fc610ef2565b6020026020010180516001019081815250506001915061081f565b6001016106fe565b50801561082e57505050610975565b818b898151811061084157610841610ef2565b602090810291909101015173ffffffffffffffffffffffffffffffffffffffff909116905261ffff8a1667ffffffffffffffff81111561088357610883610ec3565b6040519080825280602002602001820160405280156108ac578160200160208202803683370190505b508b89815181106108bf576108bf610ef2565b602002602001015160200181905250828b89815181106108e1576108e1610ef2565b6020026020010151602001516000815181106108ff576108ff610ef2565b60200260200101907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050600189898151811061095f5761095f610ef2565b6020026020010181815250508760010197505050505b6001016106a5565b5050600101610686565b5060005b8281146109df5760008482815181106109a6576109a6610ef2565b6020026020010151905060008783815181106109c4576109c4610ef2565b6020908102919091018101510151919091525060010161098b565b50508352509092915050565b600182015460609061ffff168067ffffffffffffffff811115610a1057610a10610ec3565b604051908082528060200260200182016040528015610a39578160200160208202803683370190505b50915060008060005b8361ffff16821015610b31576000818152600288016020526040812054905b80600814610b27578360010193508561ffff168411610b2757600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208b9052604090205460601c73ffffffffffffffffffffffffffffffffffffffff8a1603610b1e5780888781518110610ae657610ae6610ef2565b7fffffffff00000000000000000000000000000000000000000000000000000000909216602092830291909101909101526001909501945b50600101610a61565b5050600101610a42565b505082525092915050565b60008061016160017fca9d3e17f264b0f3984e2634e94adb37fa3e6a8103f06aeae6fa59e21c769f5e610e89565b7c01000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831601610c12576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f496e74657266616365446574656374696f6e3a2077726f6e672076616c75650060448201526064016103a2565b7fffffffff00000000000000000000000000000000000000000000000000000000919091166000908152602092909252604090912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b6020808252825182820181905260009190848201906040850190845b81811015610cc457835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101610c92565b50909695505050505050565b600081518084526020808501945080840160005b83811015610d225781517fffffffff000000000000000000000000000000000000000000000000000000001687529582019590820190600101610ce4565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b83811015610dc7578883037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00185528151805173ffffffffffffffffffffffffffffffffffffffff168452870151878401879052610db487850182610cd0565b9588019593505090860190600101610d54565b509098975050505050505050565b600060208284031215610de757600080fd5b813573ffffffffffffffffffffffffffffffffffffffff81168114610e0b57600080fd5b9392505050565b602081526000610e0b6020830184610cd0565b600060208284031215610e3757600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610e0b57600080fd5b600060208284031215610e7957600080fd5b81518015158114610e0b57600080fd5b81810381811115610161577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea26469706673582212203aa6c50ac1fd25f0bfdb0e389e142badffa38533390730696a45c39001802a8864736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100675760003560e01c80637a0ed627116100505780637a0ed62714610094578063adfca15e146100a9578063cdffacc6146100c957600080fd5b80634fe5dd791461006c57806352ef6b2c14610076575b600080fd5b610074610101565b005b61007e610124565b60405161008b9190610c76565b60405180910390f35b61009c61013b565b60405161008b9190610d2d565b6100bc6100b7366004610dd5565b61014d565b60405161008b9190610e12565b6100dc6100d7366004610e25565b610167565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161008b565b61011a61010c6101ae565b6101146102f5565b90610323565b6101226103af565b565b60606101366101316103e4565b610412565b905090565b60606101366101486103e4565b6105c7565b60606101618261015b6103e4565b906109eb565b92915050565b6000610161826101756103e4565b907fffffffff00000000000000000000000000000000000000000000000000000000166000908152602091909152604090205460601c90565b6000333214806101be5750601836105b156101c857503390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163314806102e457506040517f8929a8ca00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301523360248301527f00000000000000000000000000000000000000000000000000000000000000001690638929a8ca90604401602060405180830381865afa1580156102c0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102e49190610e67565b156102ee57919050565b3391505090565b60008061016160017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104610e89565b815473ffffffffffffffffffffffffffffffffffffffff8281169116146103ab576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f50726f787941646d696e3a206e6f74207468652061646d696e0000000000000060448201526064015b60405180910390fd5b5050565b6101227f48e2b0930000000000000000000000000000000000000000000000000000000060016103dd610b3c565b9190610b6a565b60008061016160017f65d27473a5b05206737961f69a3b7a55316862d7a6ef82b3f5455fe92fab43e3610e89565b600181015460609061ffff168067ffffffffffffffff81111561043757610437610ec3565b604051908082528060200260200182016040528015610460578160200160208202803683370190505b50915060008060005b8361ffff168210156105bd576000818152600287016020526040812054905b806008146105b3578360010193508561ffff1684116105b357600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208a9052604081205460601c90805b888114610545578a81815181106104fa576104fa610ef2565b602002602001015173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361053d5760019150610545565b6001016104e1565b508015610554575050506105ab565b818a898151811061056757610567610ef2565b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508760010197505050505b600101610488565b5050600101610469565b5050825250919050565b600181015460609061ffff168067ffffffffffffffff8111156105ec576105ec610ec3565b60405190808252806020026020018201604052801561063257816020015b60408051808201909152600081526060602082015281526020019060019003908161060a5790505b50915060008161ffff1667ffffffffffffffff81111561065457610654610ec3565b60405190808252806020026020018201604052801561067d578160200160208202803683370190505b50905060008060005b8461ffff16821015610987576000818152600288016020526040812054905b8060081461097d578360010193508661ffff16841161097d57600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208b9052604081205460601c90805b88811461081f578273ffffffffffffffffffffffffffffffffffffffff168c828151811061072e5761072e610ef2565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff160361081757838c828151811061076857610768610ef2565b6020026020010151602001518b838151811061078657610786610ef2565b60200260200101518151811061079e5761079e610ef2565b60200260200101907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815250508981815181106107fc576107fc610ef2565b6020026020010180516001019081815250506001915061081f565b6001016106fe565b50801561082e57505050610975565b818b898151811061084157610841610ef2565b602090810291909101015173ffffffffffffffffffffffffffffffffffffffff909116905261ffff8a1667ffffffffffffffff81111561088357610883610ec3565b6040519080825280602002602001820160405280156108ac578160200160208202803683370190505b508b89815181106108bf576108bf610ef2565b602002602001015160200181905250828b89815181106108e1576108e1610ef2565b6020026020010151602001516000815181106108ff576108ff610ef2565b60200260200101907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050600189898151811061095f5761095f610ef2565b6020026020010181815250508760010197505050505b6001016106a5565b5050600101610686565b5060005b8281146109df5760008482815181106109a6576109a6610ef2565b6020026020010151905060008783815181106109c4576109c4610ef2565b6020908102919091018101510151919091525060010161098b565b50508352509092915050565b600182015460609061ffff168067ffffffffffffffff811115610a1057610a10610ec3565b604051908082528060200260200182016040528015610a39578160200160208202803683370190505b50915060008060005b8361ffff16821015610b31576000818152600288016020526040812054905b80600814610b27578360010193508561ffff168411610b2757600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208b9052604090205460601c73ffffffffffffffffffffffffffffffffffffffff8a1603610b1e5780888781518110610ae657610ae6610ef2565b7fffffffff00000000000000000000000000000000000000000000000000000000909216602092830291909101909101526001909501945b50600101610a61565b5050600101610a42565b505082525092915050565b60008061016160017fca9d3e17f264b0f3984e2634e94adb37fa3e6a8103f06aeae6fa59e21c769f5e610e89565b7c01000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831601610c12576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f496e74657266616365446574656374696f6e3a2077726f6e672076616c75650060448201526064016103a2565b7fffffffff00000000000000000000000000000000000000000000000000000000919091166000908152602092909252604090912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b6020808252825182820181905260009190848201906040850190845b81811015610cc457835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101610c92565b50909695505050505050565b600081518084526020808501945080840160005b83811015610d225781517fffffffff000000000000000000000000000000000000000000000000000000001687529582019590820190600101610ce4565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b83811015610dc7578883037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00185528151805173ffffffffffffffffffffffffffffffffffffffff168452870151878401879052610db487850182610cd0565b9588019593505090860190600101610d54565b509098975050505050505050565b600060208284031215610de757600080fd5b813573ffffffffffffffffffffffffffffffffffffffff81168114610e0b57600080fd5b9392505050565b602081526000610e0b6020830184610cd0565b600060208284031215610e3757600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610e0b57600080fd5b600060208284031215610e7957600080fd5b81518015158114610e0b57600080fd5b81810381811115610161577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea26469706673582212203aa6c50ac1fd25f0bfdb0e389e142badffa38533390730696a45c39001802a8864736f6c63430008110033",
  "devdoc": {
    "details": "See https://eips.ethereum.org/EIPS/eip-2535Note: This facet depends on {ProxyAdminFacet} and {InterfaceDetectionFacet}.",
    "kind": "dev",
    "methods": {
      "facetAddress(bytes4)": {
        "params": {
          "functionSelector": "The function selector."
        },
        "returns": {
          "facetAddress_": "The facet address that supports `functionSelector`, or the zero address if the facet is not found."
        }
      },
      "facetAddresses()": {
        "returns": {
          "facetAddresses_": "The facet addresses used by the diamond."
        }
      },
      "facetFunctionSelectors(address)": {
        "params": {
          "facetAddress": "The facet address."
        },
        "returns": {
          "facetFunctionSelectors_": "The function selectors supported by `facet`."
        }
      },
      "facets()": {
        "returns": {
          "facets_": "The facet addresses used by the diamond and their function selectors."
        }
      },
      "initDiamondLoupeStorage()": {
        "details": "Reverts if the sender is not the proxy admin."
      }
    },
    "title": "Diamond Loupe (facet version).",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "facetAddress(bytes4)": {
        "notice": "Gets the facet address that supports a given function selector."
      },
      "facetAddresses()": {
        "notice": "Get all the facet addresses used by the diamond."
      },
      "facetFunctionSelectors(address)": {
        "notice": "Gets all the function selectors supported by a facet."
      },
      "facets()": {
        "notice": "Gets all the facet addresses used by the diamond and their function selectors."
      },
      "initDiamondLoupeStorage()": {
        "notice": "Marks the following ERC165 interface(s) as supported: DiamondLoupe."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}