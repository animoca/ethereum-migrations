{
  "address": "0x489f6548494145f7124b0f6aeb090B26A3807506",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IForwarderRegistry",
          "name": "forwarderRegistry",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "checkpointId",
          "type": "bytes32"
        }
      ],
      "name": "CheckpointAlreadySet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "checkpointId",
          "type": "bytes32"
        }
      ],
      "name": "CheckpointReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InconsistentArrayLengths",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "NotContractOwner",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "checkpointId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "CheckpointSet",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "checkpointIds",
          "type": "bytes32[]"
        },
        {
          "internalType": "uint256[]",
          "name": "timestamps",
          "type": "uint256[]"
        }
      ],
      "name": "batchSetCheckpoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "checkpointId",
          "type": "bytes32"
        }
      ],
      "name": "checkpoint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "checkpointId",
          "type": "bytes32"
        }
      ],
      "name": "checkpointReached",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "checkpointId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "setCheckpoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "checkpointId",
          "type": "bytes32"
        }
      ],
      "name": "triggerCheckpoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x9ba6da334cc6cfc0d0f76ea676ca0d85bfe40952ccfbc198f6467486d4417a93",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x80b12BD0F1793BF6CEa767Fa83Eb2068eaa17DC8",
    "contractAddress": null,
    "transactionIndex": 40,
    "gasUsed": "469022",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000008000000000000000800000000000000000080100000000000000000000000000000000000000000000000000000800100080000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000011000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0xc5390ecb5b36d6c687018af6118164b6bb3a1a1092028f955f62e913565a5dc2",
    "transactionHash": "0x9ba6da334cc6cfc0d0f76ea676ca0d85bfe40952ccfbc198f6467486d4417a93",
    "logs": [
      {
        "transactionIndex": 40,
        "blockNumber": 69464102,
        "transactionHash": "0x9ba6da334cc6cfc0d0f76ea676ca0d85bfe40952ccfbc198f6467486d4417a93",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000080b12bd0f1793bf6cea767fa83eb2068eaa17dc8",
          "0x00000000000000000000000083d69448f88bf9c701c1b93f43e1f753d39b2632"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000031fd30d20c83c80000000000000000000000000000000000000000000000063f5db687a8fb5ccd0000000000000000000000000000000000000000000011af4e47875ae6f579e40000000000000000000000000000000000000000000000063f2bb956d6eed9050000000000000000000000000000000000000000000011af4e79848bb901fdac",
        "logIndex": 192,
        "blockHash": "0xc5390ecb5b36d6c687018af6118164b6bb3a1a1092028f955f62e913565a5dc2"
      }
    ],
    "blockNumber": 69464102,
    "cumulativeGasUsed": "5872716",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x316a472D084489CB6d4C66e5eB62aE3AdA17521e"
  ],
  "numDeployments": 1,
  "solcInputHash": "84bab0eb3356c2e3bedca0f2f5a163c5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IForwarderRegistry\",\"name\":\"forwarderRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checkpointId\",\"type\":\"bytes32\"}],\"name\":\"CheckpointAlreadySet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checkpointId\",\"type\":\"bytes32\"}],\"name\":\"CheckpointReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InconsistentArrayLengths\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NotContractOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"checkpointId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"CheckpointSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"checkpointIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"timestamps\",\"type\":\"uint256[]\"}],\"name\":\"batchSetCheckpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checkpointId\",\"type\":\"bytes32\"}],\"name\":\"checkpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checkpointId\",\"type\":\"bytes32\"}],\"name\":\"checkpointReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checkpointId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setCheckpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"checkpointId\",\"type\":\"bytes32\"}],\"name\":\"triggerCheckpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This contract is to be used as a diamond facet (see ERC2535 Diamond Standard https://eips.ethereum.org/EIPS/eip-2535).Note: This facet depends on {ProxyAdminFacet} and {ContractOwnershipFacet}.\",\"errors\":{\"CheckpointAlreadySet(bytes32)\":[{\"params\":{\"checkpointId\":\"The checkpoint identifier.\"}}],\"CheckpointReached(bytes32)\":[{\"params\":{\"checkpointId\":\"The checkpoint identifier.\"}}],\"NotContractOwner(address)\":[{\"params\":{\"account\":\"The account that was checked.\"}}]},\"events\":{\"CheckpointSet(bytes32,uint256)\":{\"params\":{\"checkpointId\":\"The checkpoint identifier.\",\"timestamp\":\"The timestamp associated to the checkpoint.\"}}},\"kind\":\"dev\",\"methods\":{\"batchSetCheckpoint(bytes32[],uint256[])\":{\"details\":\"Reverts with {NotContractOwner} if the sender is not the contract owner.Reverts with {CheckpointAlreadySet} if one of the checkpoints is already set.Emits a {CheckpointSet} event for each timestamp set to a non-zero value.\",\"params\":{\"checkpointIds\":\"The checkpoint identifier.\",\"timestamps\":\"The checkpoint timestamp.\"}},\"checkpoint(bytes32)\":{\"params\":{\"checkpointId\":\"The checkpoint identifier.\"},\"returns\":{\"_0\":\"timestamp The timestamp associated to the checkpoint. A zero value indicates that the checkpoint is not set.\"}},\"checkpointReached(bytes32)\":{\"params\":{\"checkpointId\":\"The checkpoint identifier.\"},\"returns\":{\"_0\":\"reached True if the checkpoint has been set and the current block timestamp has already reached it, false otherwise.\"}},\"setCheckpoint(bytes32,uint256)\":{\"details\":\"Reverts with {NotContractOwner} if the sender is not the contract owner.Reverts with {CheckpointAlreadySet} if the checkpoint is already set.Emits a {CheckpointSet} event if the timestamp is set to a non-zero value.\",\"params\":{\"checkpointId\":\"The checkpoint identifiers.\",\"timestamp\":\"The checkpoint timestamps.\"}},\"triggerCheckpoint(bytes32)\":{\"details\":\"Reverts with {NotContractOwner} if the sender is not the contract owner.Reverts with {CheckpointReached} if the checkpoint is set and the current block timestamp has already reached it.Emits a {CheckpointSet} event.\",\"params\":{\"checkpointId\":\"The checkpoint identifier.\"}}},\"title\":\"Timestamp-based checkpoints management (facet version).\",\"version\":1},\"userdoc\":{\"errors\":{\"CheckpointAlreadySet(bytes32)\":[{\"notice\":\"Thrown when trying to set a checkpoint which is already set.\"}],\"CheckpointReached(bytes32)\":[{\"notice\":\"Thrown when a checkpoint has already been reached but is required not to.\"}],\"InconsistentArrayLengths()\":[{\"notice\":\"Thrown when the multiple related arrays have different lengths.\"}],\"NotContractOwner(address)\":[{\"notice\":\"Thrown when an account is not the contract owner but is required to.\"}]},\"events\":{\"CheckpointSet(bytes32,uint256)\":{\"notice\":\"Emitted when a checkpoint is set.\"}},\"kind\":\"user\",\"methods\":{\"batchSetCheckpoint(bytes32[],uint256[])\":{\"notice\":\"Sets a batch of checkpoints.\"},\"checkpoint(bytes32)\":{\"notice\":\"Gets the checkpoint timestamp.\"},\"checkpointReached(bytes32)\":{\"notice\":\"Retrieves whether the checkpoint has been reached already.\"},\"setCheckpoint(bytes32,uint256)\":{\"notice\":\"Sets the checkpoints.\"},\"triggerCheckpoint(bytes32)\":{\"notice\":\"Sets the checkpoint to the current block timestamp.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lifecycle/facets/CheckpointsFacet.sol\":\"CheckpointsFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":99999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"contracts/CommonErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when trying to transfer tokens without calldata to the contract.\\nerror EtherReceptionDisabled();\\n\\n/// @notice Thrown when the multiple related arrays have different lengths.\\nerror InconsistentArrayLengths();\\n\\n/// @notice Thrown when an ETH transfer has failed.\\nerror TransferFailed();\\n\",\"keccak256\":\"0x016ea12044fa81e3c57662985c8cfa863543ca873697926085a0f7cee10622f3\",\"license\":\"MIT\"},\"contracts/access/errors/Common.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when the target contract is actually not a contract.\\n/// @param targetContract The contract that was checked\\nerror TargetIsNotAContract(address targetContract);\\n\",\"keccak256\":\"0xffd6dcc88e984aeb996af0dedf3e3648e9e09c92efbb707377db195767ff42c5\",\"license\":\"MIT\"},\"contracts/access/errors/ContractOwnershipErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when an account is not the contract owner but is required to.\\n/// @param account The account that was checked.\\nerror NotContractOwner(address account);\\n\\n/// @notice Thrown when an account is not the pending contract owner but is required to.\\n/// @param account The account that was checked.\\nerror NotPendingContractOwner(address account);\\n\\n/// @notice Thrown when an account is not the target contract owner but is required to.\\n/// @param targetContract The contract that was checked.\\n/// @param account The account that was checked.\\nerror NotTargetContractOwner(address targetContract, address account);\\n\",\"keccak256\":\"0xcef24dac52eb52fe1241579b4d30accbee201134dbd6ef04b5b72da0c5c33e8b\",\"license\":\"MIT\"},\"contracts/access/events/ERC173Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when the contract ownership changes.\\n/// @param previousOwner the previous contract owner.\\n/// @param newOwner the new contract owner.\\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n/// @notice Emitted when a new contract owner is pending.\\n/// @param pendingOwner the address of the new contract owner.\\nevent OwnershipTransferPending(address indexed pendingOwner);\\n\",\"keccak256\":\"0xacc404adb81d8e3b68c5a8a8ce59720d100f9e04bb828be6638689d1ffaf014a\",\"license\":\"MIT\"},\"contracts/access/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC-173 Contract Ownership Standard (functions)\\n/// @dev See https://eips.ethereum.org/EIPS/eip-173\\n/// @dev Note: the ERC-165 identifier for this interface is 0x7f5828d0\\ninterface IERC173 {\\n    /// @notice Sets the address of the new contract owner.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Emits an {OwnershipTransferred} event if `newOwner` is different from the current contract owner.\\n    /// @param newOwner The address of the new contract owner. Using the zero address means renouncing ownership.\\n    function transferOwnership(address newOwner) external;\\n\\n    /// @notice Gets the address of the contract owner.\\n    /// @return contractOwner The address of the contract owner.\\n    function owner() external view returns (address contractOwner);\\n}\\n\",\"keccak256\":\"0x0dcfd1dbbfd75a6e2d564d51b9f18f1c36dcde9e0a09fa37309f89ea9b983e6a\",\"license\":\"MIT\"},\"contracts/access/libraries/ContractOwnershipStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {NotContractOwner, NotTargetContractOwner} from \\\"./../errors/ContractOwnershipErrors.sol\\\";\\nimport {TargetIsNotAContract} from \\\"./../errors/Common.sol\\\";\\nimport {OwnershipTransferred} from \\\"./../events/ERC173Events.sol\\\";\\nimport {IERC173} from \\\"./../interfaces/IERC173.sol\\\";\\nimport {Address} from \\\"./../../utils/libraries/Address.sol\\\";\\nimport {ProxyInitialization} from \\\"./../../proxy/libraries/ProxyInitialization.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./../../introspection/libraries/InterfaceDetectionStorage.sol\\\";\\n\\nlibrary ContractOwnershipStorage {\\n    using Address for address;\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n\\n    struct Layout {\\n        address contractOwner;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.access.ContractOwnership.storage\\\")) - 1);\\n    bytes32 internal constant PROXY_INIT_PHASE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.access.ContractOwnership.phase\\\")) - 1);\\n\\n    /// @notice Initializes the storage with an initial contract owner (immutable version).\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC173.\\n    /// @dev Note: This function should be called ONLY in the constructor of an immutable (non-proxied) contract.\\n    /// @dev Emits an {OwnershipTransferred} if `initialOwner` is not the zero address.\\n    /// @param initialOwner The initial contract owner.\\n    function constructorInit(Layout storage s, address initialOwner) internal {\\n        if (initialOwner != address(0)) {\\n            s.contractOwner = initialOwner;\\n            emit OwnershipTransferred(address(0), initialOwner);\\n        }\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC173).interfaceId, true);\\n    }\\n\\n    /// @notice Initializes the storage with an initial contract owner (proxied version).\\n    /// @notice Sets the proxy initialization phase to `1`.\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC173.\\n    /// @dev Note: This function should be called ONLY in the init function of a proxied contract.\\n    /// @dev Reverts with {InitializationPhaseAlreadyReached} if the proxy initialization phase is set to `1` or above.\\n    /// @dev Emits an {OwnershipTransferred} if `initialOwner` is not the zero address.\\n    /// @param initialOwner The initial contract owner.\\n    function proxyInit(Layout storage s, address initialOwner) internal {\\n        ProxyInitialization.setPhase(PROXY_INIT_PHASE_SLOT, 1);\\n        s.constructorInit(initialOwner);\\n    }\\n\\n    /// @notice Sets the address of the new contract owner.\\n    /// @dev Reverts with {NotContractOwner} if `sender` is not the contract owner.\\n    /// @dev Emits an {OwnershipTransferred} event if `newOwner` is different from the current contract owner.\\n    /// @param newOwner The address of the new contract owner. Using the zero address means renouncing ownership.\\n    function transferOwnership(Layout storage s, address sender, address newOwner) internal {\\n        address previousOwner = s.contractOwner;\\n        if (sender != previousOwner) revert NotContractOwner(sender);\\n        if (previousOwner != newOwner) {\\n            s.contractOwner = newOwner;\\n            emit OwnershipTransferred(previousOwner, newOwner);\\n        }\\n    }\\n\\n    /// @notice Gets the address of the contract owner.\\n    /// @return contractOwner The address of the contract owner.\\n    function owner(Layout storage s) internal view returns (address contractOwner) {\\n        return s.contractOwner;\\n    }\\n\\n    /// @notice Checks whether an account is the owner of a target contract.\\n    /// @param targetContract The contract to check.\\n    /// @param account The account to check.\\n    /// @return isTargetContractOwner_ Whether `account` is the owner of `targetContract`.\\n    function isTargetContractOwner(address targetContract, address account) internal view returns (bool isTargetContractOwner_) {\\n        if (!targetContract.hasBytecode()) revert TargetIsNotAContract(targetContract);\\n        return IERC173(targetContract).owner() == account;\\n    }\\n\\n    /// @notice Ensures that an account is the contract owner.\\n    /// @dev Reverts with {NotContractOwner} if `account` is not the contract owner.\\n    /// @param account The account.\\n    function enforceIsContractOwner(Layout storage s, address account) internal view {\\n        if (account != s.contractOwner) revert NotContractOwner(account);\\n    }\\n\\n    /// @notice Enforces that an account is the owner of a target contract.\\n    /// @dev Reverts with {NotTheTargetContractOwner} if the account is not the owner.\\n    /// @param targetContract The contract to check.\\n    /// @param account The account to check.\\n    function enforceIsTargetContractOwner(address targetContract, address account) internal view {\\n        if (!isTargetContractOwner(targetContract, account)) revert NotTargetContractOwner(targetContract, account);\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeb170039cf4e40fbdf199c1272eb87ba6117e85f4df5eee0d19708b93665225a\",\"license\":\"MIT\"},\"contracts/introspection/errors/InterfaceDetectionErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when setting the illegal interfaceId 0xffffffff.\\nerror IllegalInterfaceId();\\n\",\"keccak256\":\"0x0fd7df6f16ddbcaf3f5b8f603a12c0516e1dc5ee08eb770da52691adf070e0bd\",\"license\":\"MIT\"},\"contracts/introspection/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC165 Interface Detection Standard.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-165.\\n/// @dev Note: The ERC-165 identifier for this interface is 0x01ffc9a7.\\ninterface IERC165 {\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId the interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool supported);\\n}\\n\",\"keccak256\":\"0x34f460e915aaaec82d62c228f4813ca758b487034eaa43b65c128389539194d9\",\"license\":\"MIT\"},\"contracts/introspection/libraries/InterfaceDetectionStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IllegalInterfaceId} from \\\"./../errors/InterfaceDetectionErrors.sol\\\";\\nimport {IERC165} from \\\"./../interfaces/IERC165.sol\\\";\\n\\nlibrary InterfaceDetectionStorage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.introspection.InterfaceDetection.storage\\\")) - 1);\\n\\n    bytes4 internal constant ILLEGAL_INTERFACE_ID = 0xffffffff;\\n\\n    /// @notice Sets or unsets an ERC165 interface.\\n    /// @dev Revertswith {IllegalInterfaceId} if `interfaceId` is `0xffffffff`.\\n    /// @param interfaceId the interface identifier.\\n    /// @param supported True to set the interface, false to unset it.\\n    function setSupportedInterface(Layout storage s, bytes4 interfaceId, bool supported) internal {\\n        if (interfaceId == ILLEGAL_INTERFACE_ID) revert IllegalInterfaceId();\\n        s.supportedInterfaces[interfaceId] = supported;\\n    }\\n\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId The interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(Layout storage s, bytes4 interfaceId) internal view returns (bool supported) {\\n        if (interfaceId == ILLEGAL_INTERFACE_ID) {\\n            return false;\\n        }\\n        if (interfaceId == type(IERC165).interfaceId) {\\n            return true;\\n        }\\n        return s.supportedInterfaces[interfaceId];\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeaf559662562be7885b75193ff6994e52cf8109c898ffced02c2b26785d94ee2\",\"license\":\"MIT\"},\"contracts/lifecycle/base/CheckpointsBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {ICheckpoints} from \\\"./../interfaces/ICheckpoints.sol\\\";\\nimport {CheckpointsStorage} from \\\"./../libraries/CheckpointsStorage.sol\\\";\\nimport {ContractOwnershipStorage} from \\\"./../../access/libraries/ContractOwnershipStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title Timestamp-based checkpoints management (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC173 (Contract Ownership standard).\\nabstract contract CheckpointsBase is ICheckpoints, Context {\\n    using CheckpointsStorage for CheckpointsStorage.Layout;\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n\\n    /// @notice Sets the checkpoints.\\n    /// @dev Reverts with {NotContractOwner} if the sender is not the contract owner.\\n    /// @dev Reverts with {CheckpointAlreadySet} if the checkpoint is already set.\\n    /// @dev Emits a {CheckpointSet} event if the timestamp is set to a non-zero value.\\n    /// @param checkpointId The checkpoint identifiers.\\n    /// @param timestamp The checkpoint timestamps.\\n    function setCheckpoint(bytes32 checkpointId, uint256 timestamp) external {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        CheckpointsStorage.layout().setCheckpoint(checkpointId, timestamp);\\n    }\\n\\n    /// @notice Sets a batch of checkpoints.\\n    /// @dev Reverts with {NotContractOwner} if the sender is not the contract owner.\\n    /// @dev Reverts with {CheckpointAlreadySet} if one of the checkpoints is already set.\\n    /// @dev Emits a {CheckpointSet} event for each timestamp set to a non-zero value.\\n    /// @param checkpointIds The checkpoint identifier.\\n    /// @param timestamps The checkpoint timestamp.\\n    function batchSetCheckpoint(bytes32[] calldata checkpointIds, uint256[] calldata timestamps) external {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        CheckpointsStorage.layout().batchSetCheckpoint(checkpointIds, timestamps);\\n    }\\n\\n    /// @notice Sets the checkpoint to the current block timestamp.\\n    /// @dev Reverts with {NotContractOwner} if the sender is not the contract owner.\\n    /// @dev Reverts with {CheckpointReached} if the checkpoint is set and the current block timestamp has already reached it.\\n    /// @dev Emits a {CheckpointSet} event.\\n    /// @param checkpointId The checkpoint identifier.\\n    function triggerCheckpoint(bytes32 checkpointId) external {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        CheckpointsStorage.layout().triggerCheckpoint(checkpointId);\\n    }\\n\\n    /// @inheritdoc ICheckpoints\\n    function checkpoint(bytes32 checkpointId) external view returns (uint256) {\\n        return CheckpointsStorage.layout().checkpoint(checkpointId);\\n    }\\n\\n    /// @inheritdoc ICheckpoints\\n    function checkpointReached(bytes32 checkpointId) external view returns (bool) {\\n        return CheckpointsStorage.layout().checkpointReached(checkpointId);\\n    }\\n}\\n\",\"keccak256\":\"0x29bda3bee68ebcf69596673c18deaba9c51f19899eb7c1a7c486898b6b1e1fcb\",\"license\":\"MIT\"},\"contracts/lifecycle/errors/CheckpointsErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when trying to set a checkpoint which is already set.\\n/// @param checkpointId The checkpoint identifier.\\nerror CheckpointAlreadySet(bytes32 checkpointId);\\n\\n/// @notice Thrown when a checkpoint has not been reached yet but is required to.\\n/// @param checkpointId The checkpoint identifier.\\nerror CheckpointNotReached(bytes32 checkpointId);\\n\\n/// @notice Thrown when a checkpoint has already been reached but is required not to.\\n/// @param checkpointId The checkpoint identifier.\\nerror CheckpointReached(bytes32 checkpointId);\\n\",\"keccak256\":\"0x559cff1a0e8af3fe8cc4051134d7bcea796de71f3a788cabe334c373e3c66fc1\",\"license\":\"MIT\"},\"contracts/lifecycle/events/CheckpointsEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when a checkpoint is set.\\n/// @param checkpointId The checkpoint identifier.\\n/// @param timestamp The timestamp associated to the checkpoint.\\nevent CheckpointSet(bytes32 checkpointId, uint256 timestamp);\\n\",\"keccak256\":\"0x43b0884960a6a6b4de833c4c4b558c20099df11213ac891fe897b33696c13381\",\"license\":\"MIT\"},\"contracts/lifecycle/facets/CheckpointsFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.28;\\n\\nimport {IForwarderRegistry} from \\\"./../../metatx/interfaces/IForwarderRegistry.sol\\\";\\nimport {ProxyAdminStorage} from \\\"./../../proxy/libraries/ProxyAdminStorage.sol\\\";\\nimport {CheckpointsBase} from \\\"./../base/CheckpointsBase.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {ForwarderRegistryContextBase} from \\\"./../../metatx/base/ForwarderRegistryContextBase.sol\\\";\\n\\n/// @title Timestamp-based checkpoints management (facet version).\\n/// @dev This contract is to be used as a diamond facet (see ERC2535 Diamond Standard https://eips.ethereum.org/EIPS/eip-2535).\\n/// @dev Note: This facet depends on {ProxyAdminFacet} and {ContractOwnershipFacet}.\\ncontract CheckpointsFacet is CheckpointsBase, ForwarderRegistryContextBase {\\n    using ProxyAdminStorage for ProxyAdminStorage.Layout;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) ForwarderRegistryContextBase(forwarderRegistry) {}\\n\\n    /// @inheritdoc ForwarderRegistryContextBase\\n    function _msgSender() internal view virtual override(Context, ForwarderRegistryContextBase) returns (address) {\\n        return ForwarderRegistryContextBase._msgSender();\\n    }\\n\\n    /// @inheritdoc ForwarderRegistryContextBase\\n    function _msgData() internal view virtual override(Context, ForwarderRegistryContextBase) returns (bytes calldata) {\\n        return ForwarderRegistryContextBase._msgData();\\n    }\\n}\\n\",\"keccak256\":\"0x5364fb50e1f8869746d3deca2cd6db4e35427469a0e0c10ff4bef20d2f893083\",\"license\":\"MIT\"},\"contracts/lifecycle/interfaces/ICheckpoints.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title Timestamp-based checkpoints management (functions)\\ninterface ICheckpoints {\\n    /// @notice Gets the checkpoint timestamp.\\n    /// @param checkpointId The checkpoint identifier.\\n    /// @return timestamp The timestamp associated to the checkpoint. A zero value indicates that the checkpoint is not set.\\n    function checkpoint(bytes32 checkpointId) external view returns (uint256);\\n\\n    /// @notice Retrieves whether the checkpoint has been reached already.\\n    /// @param checkpointId The checkpoint identifier.\\n    /// @return reached True if the checkpoint has been set and the current block timestamp has already reached it, false otherwise.\\n    function checkpointReached(bytes32 checkpointId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x072a490560af6c5c17c1e4d940d7bbbff8f8f1e9d483d4409126010b2d003520\",\"license\":\"MIT\"},\"contracts/lifecycle/libraries/CheckpointsStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {CheckpointAlreadySet, CheckpointNotReached, CheckpointReached} from \\\"./../errors/CheckpointsErrors.sol\\\";\\nimport {InconsistentArrayLengths} from \\\"./../../CommonErrors.sol\\\";\\nimport {CheckpointSet} from \\\"./../events/CheckpointsEvents.sol\\\";\\n\\nlibrary CheckpointsStorage {\\n    using CheckpointsStorage for CheckpointsStorage.Layout;\\n\\n    struct Layout {\\n        // checkpointId => timestamp\\n        mapping(bytes32 => uint256) checkpoints;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.lifecycle.Checkpoints.storage\\\")) - 1);\\n\\n    /// @notice Sets the checkpoint.\\n    /// @dev Reverts with {CheckpointAlreadySet} if the checkpoint is already set.\\n    /// @dev Emits a {CheckpointSet} event if the timestamp is set to a non-zero value.\\n    /// @param checkpointId The checkpoint identifier.\\n    /// @param timestamp The checkpoint timestamp.\\n    function setCheckpoint(Layout storage s, bytes32 checkpointId, uint256 timestamp) internal {\\n        if (s.checkpoints[checkpointId] != 0) revert CheckpointAlreadySet(checkpointId);\\n        if (timestamp != 0) {\\n            s.checkpoints[checkpointId] = timestamp;\\n            emit CheckpointSet(checkpointId, timestamp);\\n        }\\n    }\\n\\n    /// @notice Sets a batch of checkpoints.\\n    /// @dev Reverts with {CheckpointAlreadySet} if one of the checkpoints is already set.\\n    /// @dev Emits a {CheckpointSet} event for each timestamp set to a non-zero value.\\n    /// @param checkpointIds The checkpoint identifiers.\\n    /// @param timestamps The checkpoint timestamps.\\n    function batchSetCheckpoint(Layout storage s, bytes32[] calldata checkpointIds, uint256[] calldata timestamps) internal {\\n        uint256 length = checkpointIds.length;\\n        if (length != timestamps.length) revert InconsistentArrayLengths();\\n\\n        for (uint256 i; i < length; ++i) {\\n            s.setCheckpoint(checkpointIds[i], timestamps[i]);\\n        }\\n    }\\n\\n    /// @notice Sets the checkpoint to the current block timestamp.\\n    /// @dev Reverts with {CheckpointReached} if the checkpoint is set and the current block timestamp has already reached it.\\n    /// @dev Emits a {CheckpointSet} event.\\n    /// @param checkpointId The checkpoint identifier.\\n    function triggerCheckpoint(Layout storage s, bytes32 checkpointId) internal {\\n        s.enforceCheckpointNotReached(checkpointId);\\n        s.checkpoints[checkpointId] = block.timestamp;\\n        emit CheckpointSet(checkpointId, block.timestamp);\\n    }\\n\\n    /// @notice Gets the checkpoint timestamp.\\n    /// @param checkpointId The checkpoint identifier.\\n    /// @return timestamp The timestamp associated to the checkpoint. A zero value indicates that the checkpoint is not set.\\n    function checkpoint(Layout storage s, bytes32 checkpointId) internal view returns (uint256 timestamp) {\\n        return s.checkpoints[checkpointId];\\n    }\\n\\n    /// @notice Retrieves whether the checkpoint has been reached already.\\n    /// @param checkpointId The checkpoint identifier.\\n    /// @return reached True if the checkpoint has been set and the current block timestamp has already reached it, false otherwise.\\n    function checkpointReached(Layout storage s, bytes32 checkpointId) internal view returns (bool) {\\n        uint256 checkpoint_ = s.checkpoints[checkpointId];\\n        return checkpoint_ != 0 && block.timestamp >= checkpoint_;\\n    }\\n\\n    /// @notice Ensures that the checkpoint has been reached already.\\n    /// @dev Reverts with {CheckpointNotReached} if the checkpoint is not set or if the current block timestamp has not reached it yet.\\n    /// @param checkpointId The checkpoint identifier.\\n    function enforceCheckpointReached(Layout storage s, bytes32 checkpointId) internal view {\\n        if (!s.checkpointReached(checkpointId)) revert CheckpointNotReached(checkpointId);\\n    }\\n\\n    /// @notice Ensures that the checkpoint has not been reached yet.\\n    /// @dev Reverts with {CheckpointReached} if checkpoint is set and the current block timestamp has already reached it.\\n    /// @param checkpointId The checkpoint identifier.\\n    function enforceCheckpointNotReached(Layout storage s, bytes32 checkpointId) internal view {\\n        if (s.checkpointReached(checkpointId)) revert CheckpointReached(checkpointId);\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe259a7be958b672ae7a7f3184431c38dff366d8669d51fa06dd42d3ba9c73a79\",\"license\":\"MIT\"},\"contracts/metatx/base/ForwarderRegistryContextBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IForwarderRegistry} from \\\"./../interfaces/IForwarderRegistry.sol\\\";\\nimport {ERC2771Calldata} from \\\"./../libraries/ERC2771Calldata.sol\\\";\\n\\n/// @title Meta-Transactions Forwarder Registry Context (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Derived from https://github.com/wighawag/universal-forwarder (MIT licence)\\nabstract contract ForwarderRegistryContextBase {\\n    IForwarderRegistry internal immutable _FORWARDER_REGISTRY;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) {\\n        _FORWARDER_REGISTRY = forwarderRegistry;\\n    }\\n\\n    /// @notice Returns the message sender depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgSender() internal view virtual returns (address) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.sender;\\n        }\\n\\n        address sender = ERC2771Calldata.msgSender();\\n\\n        // Return the EIP-2771 calldata-appended sender address if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (msg.sender == address(_FORWARDER_REGISTRY) || _FORWARDER_REGISTRY.isApprovedForwarder(sender, msg.sender, address(this))) {\\n            return sender;\\n        }\\n\\n        return msg.sender;\\n    }\\n\\n    /// @notice Returns the message data depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.data;\\n        }\\n\\n        // Return the EIP-2771 calldata (minus the appended sender) if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (\\n            msg.sender == address(_FORWARDER_REGISTRY) ||\\n            _FORWARDER_REGISTRY.isApprovedForwarder(ERC2771Calldata.msgSender(), msg.sender, address(this))\\n        ) {\\n            return ERC2771Calldata.msgData();\\n        }\\n\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x9a024b7aa6527471d6a097c62dfa94e85a1427ec63776153aff9e5d7ba229040\",\"license\":\"MIT\"},\"contracts/metatx/interfaces/IForwarderRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title Meta-Transactions Forwarder Registry.\\ninterface IForwarderRegistry {\\n    /// @notice Checks whether an account is as an approved meta-transaction forwarder for a sender account to a target contract.\\n    /// @param sender The sender account.\\n    /// @param forwarder The forwarder account.\\n    /// @param target The target contract.\\n    /// @return isApproved True if `forwarder` is an approved meta-transaction forwarder for `sender` to `target`, false otherwise.\\n    function isApprovedForwarder(address sender, address forwarder, address target) external view returns (bool isApproved);\\n}\\n\",\"keccak256\":\"0xdfb17430660876a9214c0cc4c37eb688c565b3c8211151b3413d88d5b4e4c4cb\",\"license\":\"MIT\"},\"contracts/metatx/libraries/ERC2771Calldata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @dev Derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT licence)\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2771\\nlibrary ERC2771Calldata {\\n    /// @notice Returns the sender address appended at the end of the calldata, as specified in EIP-2771.\\n    function msgSender() internal pure returns (address sender) {\\n        assembly {\\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n    /// @notice Returns the calldata while omitting the appended sender address, as specified in EIP-2771.\\n    function msgData() internal pure returns (bytes calldata data) {\\n        unchecked {\\n            return msg.data[:msg.data.length - 20];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8de5057207aa02ba450c95d802f3f77736cafeb1c4e516d6989c27ff5fa1315d\",\"license\":\"MIT\"},\"contracts/proxy/errors/ProxyAdminErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when the initial admin is not set.\\nerror NoInitialProxyAdmin();\\n\\n/// @notice Thrown when an account is not the proxy admin but is required to.\\n/// @param account The account that was checked.\\nerror NotProxyAdmin(address account);\\n\",\"keccak256\":\"0x8ba37d9f154407fc3ddc058b5f678866b274a9674cd850bd8bf73d79e626c160\",\"license\":\"MIT\"},\"contracts/proxy/errors/ProxyInitializationErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when trying to set a phase value that has already been reached.\\n/// @param currentPhase The current phase.\\n/// @param newPhase The new phase trying to be set.\\nerror InitializationPhaseAlreadyReached(uint256 currentPhase, uint256 newPhase);\\n\",\"keccak256\":\"0x85ee7912d0020d0f032e2dacacbec057114235fbdab703753fdcde5c78275543\",\"license\":\"MIT\"},\"contracts/proxy/events/ProxyAdminEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when the proxy admin changes.\\n/// @param previousAdmin the previous admin.\\n/// @param newAdmin the new admin.\\nevent AdminChanged(address previousAdmin, address newAdmin);\\n\",\"keccak256\":\"0x8af172a87e9b4f1188e7837f4aaac8bdb438191b1465cc963f4543da1a435476\",\"license\":\"MIT\"},\"contracts/proxy/libraries/ProxyAdminStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {NoInitialProxyAdmin, NotProxyAdmin} from \\\"./../errors/ProxyAdminErrors.sol\\\";\\nimport {AdminChanged} from \\\"./../events/ProxyAdminEvents.sol\\\";\\nimport {ProxyInitialization} from \\\"./ProxyInitialization.sol\\\";\\n\\nlibrary ProxyAdminStorage {\\n    using ProxyAdminStorage for ProxyAdminStorage.Layout;\\n\\n    struct Layout {\\n        address admin;\\n    }\\n\\n    // bytes32 public constant PROXYADMIN_STORAGE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n    bytes32 internal constant PROXY_INIT_PHASE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin.phase\\\")) - 1);\\n\\n    /// @notice Initializes the storage with an initial admin (immutable version).\\n    /// @dev Note: This function should be called ONLY in the constructor of an immutable (non-proxied) contract.\\n    /// @dev Reverts {NoInitialProxyAdmin} if `initialAdmin` is the zero address.\\n    /// @dev Emits an {AdminChanged} event.\\n    /// @param initialAdmin The initial payout wallet.\\n    function constructorInit(Layout storage s, address initialAdmin) internal {\\n        if (initialAdmin == address(0)) revert NoInitialProxyAdmin();\\n        s.admin = initialAdmin;\\n        emit AdminChanged(address(0), initialAdmin);\\n    }\\n\\n    /// @notice Initializes the storage with an initial admin (proxied version).\\n    /// @notice Sets the proxy initialization phase to `1`.\\n    /// @dev Note: This function should be called ONLY in the init function of a proxied contract.\\n    /// @dev Reverts with {InitializationPhaseAlreadyReached} if the proxy initialization phase is set to `1` or above.\\n    /// @dev Reverts {NoInitialProxyAdmin} if `initialAdmin` is the zero address.\\n    /// @dev Emits an {AdminChanged} event.\\n    /// @param initialAdmin The initial payout wallet.\\n    function proxyInit(Layout storage s, address initialAdmin) internal {\\n        ProxyInitialization.setPhase(PROXY_INIT_PHASE_SLOT, 1);\\n        s.constructorInit(initialAdmin);\\n    }\\n\\n    /// @notice Sets a new proxy admin.\\n    /// @dev Reverts with {NotProxyAdmin} if `sender` is not the proxy admin.\\n    /// @dev Emits an {AdminChanged} event if `newAdmin` is different from the current proxy admin.\\n    /// @param newAdmin The new proxy admin.\\n    function changeProxyAdmin(Layout storage s, address sender, address newAdmin) internal {\\n        address previousAdmin = s.admin;\\n        if (sender != previousAdmin) revert NotProxyAdmin(sender);\\n        if (previousAdmin != newAdmin) {\\n            s.admin = newAdmin;\\n            emit AdminChanged(previousAdmin, newAdmin);\\n        }\\n    }\\n\\n    /// @notice Gets the proxy admin.\\n    /// @return admin The proxy admin\\n    function proxyAdmin(Layout storage s) internal view returns (address admin) {\\n        return s.admin;\\n    }\\n\\n    /// @notice Ensures that an account is the proxy admin.\\n    /// @dev Reverts with {NotProxyAdmin} if `account` is not the proxy admin.\\n    /// @param account The account.\\n    function enforceIsProxyAdmin(Layout storage s, address account) internal view {\\n        if (account != s.admin) revert NotProxyAdmin(account);\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1f1cb9a6470f14aa9942dedd288aaffc6c582abf831edeb52e51a3691cdd32a4\",\"license\":\"MIT\"},\"contracts/proxy/libraries/ProxyInitialization.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {InitializationPhaseAlreadyReached} from \\\"./../errors/ProxyInitializationErrors.sol\\\";\\nimport {StorageSlot} from \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n/// @notice Multiple calls protection for storage-modifying proxy initialization functions.\\nlibrary ProxyInitialization {\\n    /// @notice Sets the initialization phase during a storage-modifying proxy initialization function.\\n    /// @dev Reverts with {InitializationPhaseAlreadyReached} if `phase` has been reached already.\\n    /// @param storageSlot the storage slot where `phase` is stored.\\n    /// @param phase the initialization phase.\\n    function setPhase(bytes32 storageSlot, uint256 phase) internal {\\n        StorageSlot.Uint256Slot storage currentVersion = StorageSlot.getUint256Slot(storageSlot);\\n        uint256 currentPhase = currentVersion.value;\\n        if (currentPhase >= phase) revert InitializationPhaseAlreadyReached(currentPhase, phase);\\n        currentVersion.value = phase;\\n    }\\n}\\n\",\"keccak256\":\"0xdc2cca29702fe573cb5af8c3320eafe7a490aef99bcaafe1e6575159bb0007d7\",\"license\":\"MIT\"},\"contracts/utils/libraries/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nlibrary Address {\\n    /// @notice Checks if the address is a deployed smart contract.\\n    /// @param addr The address to check.\\n    /// @return hasBytecode True if `addr` is a deployed smart contract, false otherwise.\\n    function hasBytecode(address addr) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size != 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf3119a6298c6da4e7da69344ae8ab51a6a64dc08c68f826a560e72d46cf0ad9c\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a0604052348015600f57600080fd5b50604051610810380380610810833981016040819052602c91603c565b6001600160a01b0316608052606a565b600060208284031215604d57600080fd5b81516001600160a01b0381168114606357600080fd5b9392505050565b60805161078461008c60003960008181610476015261050401526107846000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c80634f410a80116100505780634f410a80146100a95780635b34eba0146100bc578063deb4d746146100dd57600080fd5b8063151bdba61461006c5780633b14936914610094575b600080fd5b61007f61007a3660046105c4565b6100f0565b60405190151581526020015b60405180910390f35b6100a76100a2366004610629565b61010a565b005b6100a76100b736600461069a565b610141565b6100cf6100ca3660046105c4565b610164565b60405190815260200161008b565b6100a76100eb3660046105c4565b610182565b6000610104826100fe6101a2565b906101d0565b92915050565b6101236101156101f6565b61011d610205565b90610233565b61013b848484846101326101a2565b939291906102a3565b50505050565b61014c6101156101f6565b61016082826101596101a2565b919061033e565b5050565b6000610104826101726101a2565b6000918252602052604090205490565b61018d6101156101f6565b61019f816101996101a2565b906103dc565b50565b60008061010460017f0def758eb96c12015155889b8e63d1cb5c0dbce5585bbdf9d99ea353f56c716c6106bc565b60008181526020839052604081205480158015906101ee5750804210155b949350505050565b6000610200610433565b905090565b60008061010460017fc9ed16f33ab3a66c84bfd83099ccb2a8845871e2e1c1928f63797152f0fd54cd6106bc565b815473ffffffffffffffffffffffffffffffffffffffff828116911614610160576040517f2ef4875e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024015b60405180910390fd5b828181146102dd576040517f6582533600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b818110156103355761032d8686838181106102fd576102fd6106f6565b90506020020135858584818110610316576103166106f6565b905060200201358961033e9092919063ffffffff16565b6001016102e0565b50505050505050565b60008281526020849052604090205415610387576040517f33e962eb0000000000000000000000000000000000000000000000000000000081526004810183905260240161029a565b80156103d7576000828152602084815260409182902083905581518481529081018390527f099ea97db121bdf4a102e67113e27b6bb74713015b32a5f0e1c3ea0d44fb2953910160405180910390a15b505050565b6103e68282610580565b6000818152602083815260409182902042908190558251848152918201527f099ea97db121bdf4a102e67113e27b6bb74713015b32a5f0e1c3ea0d44fb2953910160405180910390a15050565b6000333214806104435750601836105b1561044d57503390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1633148061056f57506040517f019a202800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301523360248301523060448301527f0000000000000000000000000000000000000000000000000000000000000000169063019a202890606401602060405180830381865afa15801561054b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056f9190610725565b1561057957919050565b3391505090565b61058a82826101d0565b15610160576040517f8e54d9090000000000000000000000000000000000000000000000000000000081526004810182905260240161029a565b6000602082840312156105d657600080fd5b5035919050565b60008083601f8401126105ef57600080fd5b50813567ffffffffffffffff81111561060757600080fd5b6020830191508360208260051b850101111561062257600080fd5b9250929050565b6000806000806040858703121561063f57600080fd5b843567ffffffffffffffff81111561065657600080fd5b610662878288016105dd565b909550935050602085013567ffffffffffffffff81111561068257600080fd5b61068e878288016105dd565b95989497509550505050565b600080604083850312156106ad57600080fd5b50508035926020909101359150565b81810381811115610104577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006020828403121561073757600080fd5b8151801515811461074757600080fd5b939250505056fea26469706673582212207d92048d17a793109334c45f833f2b3c87c62b93d7361572e2b1f1fd2bd3426364736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100675760003560e01c80634f410a80116100505780634f410a80146100a95780635b34eba0146100bc578063deb4d746146100dd57600080fd5b8063151bdba61461006c5780633b14936914610094575b600080fd5b61007f61007a3660046105c4565b6100f0565b60405190151581526020015b60405180910390f35b6100a76100a2366004610629565b61010a565b005b6100a76100b736600461069a565b610141565b6100cf6100ca3660046105c4565b610164565b60405190815260200161008b565b6100a76100eb3660046105c4565b610182565b6000610104826100fe6101a2565b906101d0565b92915050565b6101236101156101f6565b61011d610205565b90610233565b61013b848484846101326101a2565b939291906102a3565b50505050565b61014c6101156101f6565b61016082826101596101a2565b919061033e565b5050565b6000610104826101726101a2565b6000918252602052604090205490565b61018d6101156101f6565b61019f816101996101a2565b906103dc565b50565b60008061010460017f0def758eb96c12015155889b8e63d1cb5c0dbce5585bbdf9d99ea353f56c716c6106bc565b60008181526020839052604081205480158015906101ee5750804210155b949350505050565b6000610200610433565b905090565b60008061010460017fc9ed16f33ab3a66c84bfd83099ccb2a8845871e2e1c1928f63797152f0fd54cd6106bc565b815473ffffffffffffffffffffffffffffffffffffffff828116911614610160576040517f2ef4875e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024015b60405180910390fd5b828181146102dd576040517f6582533600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b818110156103355761032d8686838181106102fd576102fd6106f6565b90506020020135858584818110610316576103166106f6565b905060200201358961033e9092919063ffffffff16565b6001016102e0565b50505050505050565b60008281526020849052604090205415610387576040517f33e962eb0000000000000000000000000000000000000000000000000000000081526004810183905260240161029a565b80156103d7576000828152602084815260409182902083905581518481529081018390527f099ea97db121bdf4a102e67113e27b6bb74713015b32a5f0e1c3ea0d44fb2953910160405180910390a15b505050565b6103e68282610580565b6000818152602083815260409182902042908190558251848152918201527f099ea97db121bdf4a102e67113e27b6bb74713015b32a5f0e1c3ea0d44fb2953910160405180910390a15050565b6000333214806104435750601836105b1561044d57503390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1633148061056f57506040517f019a202800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301523360248301523060448301527f0000000000000000000000000000000000000000000000000000000000000000169063019a202890606401602060405180830381865afa15801561054b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056f9190610725565b1561057957919050565b3391505090565b61058a82826101d0565b15610160576040517f8e54d9090000000000000000000000000000000000000000000000000000000081526004810182905260240161029a565b6000602082840312156105d657600080fd5b5035919050565b60008083601f8401126105ef57600080fd5b50813567ffffffffffffffff81111561060757600080fd5b6020830191508360208260051b850101111561062257600080fd5b9250929050565b6000806000806040858703121561063f57600080fd5b843567ffffffffffffffff81111561065657600080fd5b610662878288016105dd565b909550935050602085013567ffffffffffffffff81111561068257600080fd5b61068e878288016105dd565b95989497509550505050565b600080604083850312156106ad57600080fd5b50508035926020909101359150565b81810381811115610104577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006020828403121561073757600080fd5b8151801515811461074757600080fd5b939250505056fea26469706673582212207d92048d17a793109334c45f833f2b3c87c62b93d7361572e2b1f1fd2bd3426364736f6c634300081c0033",
  "devdoc": {
    "details": "This contract is to be used as a diamond facet (see ERC2535 Diamond Standard https://eips.ethereum.org/EIPS/eip-2535).Note: This facet depends on {ProxyAdminFacet} and {ContractOwnershipFacet}.",
    "errors": {
      "CheckpointAlreadySet(bytes32)": [
        {
          "params": {
            "checkpointId": "The checkpoint identifier."
          }
        }
      ],
      "CheckpointReached(bytes32)": [
        {
          "params": {
            "checkpointId": "The checkpoint identifier."
          }
        }
      ],
      "NotContractOwner(address)": [
        {
          "params": {
            "account": "The account that was checked."
          }
        }
      ]
    },
    "events": {
      "CheckpointSet(bytes32,uint256)": {
        "params": {
          "checkpointId": "The checkpoint identifier.",
          "timestamp": "The timestamp associated to the checkpoint."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "batchSetCheckpoint(bytes32[],uint256[])": {
        "details": "Reverts with {NotContractOwner} if the sender is not the contract owner.Reverts with {CheckpointAlreadySet} if one of the checkpoints is already set.Emits a {CheckpointSet} event for each timestamp set to a non-zero value.",
        "params": {
          "checkpointIds": "The checkpoint identifier.",
          "timestamps": "The checkpoint timestamp."
        }
      },
      "checkpoint(bytes32)": {
        "params": {
          "checkpointId": "The checkpoint identifier."
        },
        "returns": {
          "_0": "timestamp The timestamp associated to the checkpoint. A zero value indicates that the checkpoint is not set."
        }
      },
      "checkpointReached(bytes32)": {
        "params": {
          "checkpointId": "The checkpoint identifier."
        },
        "returns": {
          "_0": "reached True if the checkpoint has been set and the current block timestamp has already reached it, false otherwise."
        }
      },
      "setCheckpoint(bytes32,uint256)": {
        "details": "Reverts with {NotContractOwner} if the sender is not the contract owner.Reverts with {CheckpointAlreadySet} if the checkpoint is already set.Emits a {CheckpointSet} event if the timestamp is set to a non-zero value.",
        "params": {
          "checkpointId": "The checkpoint identifiers.",
          "timestamp": "The checkpoint timestamps."
        }
      },
      "triggerCheckpoint(bytes32)": {
        "details": "Reverts with {NotContractOwner} if the sender is not the contract owner.Reverts with {CheckpointReached} if the checkpoint is set and the current block timestamp has already reached it.Emits a {CheckpointSet} event.",
        "params": {
          "checkpointId": "The checkpoint identifier."
        }
      }
    },
    "title": "Timestamp-based checkpoints management (facet version).",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "CheckpointAlreadySet(bytes32)": [
        {
          "notice": "Thrown when trying to set a checkpoint which is already set."
        }
      ],
      "CheckpointReached(bytes32)": [
        {
          "notice": "Thrown when a checkpoint has already been reached but is required not to."
        }
      ],
      "InconsistentArrayLengths()": [
        {
          "notice": "Thrown when the multiple related arrays have different lengths."
        }
      ],
      "NotContractOwner(address)": [
        {
          "notice": "Thrown when an account is not the contract owner but is required to."
        }
      ]
    },
    "events": {
      "CheckpointSet(bytes32,uint256)": {
        "notice": "Emitted when a checkpoint is set."
      }
    },
    "kind": "user",
    "methods": {
      "batchSetCheckpoint(bytes32[],uint256[])": {
        "notice": "Sets a batch of checkpoints."
      },
      "checkpoint(bytes32)": {
        "notice": "Gets the checkpoint timestamp."
      },
      "checkpointReached(bytes32)": {
        "notice": "Retrieves whether the checkpoint has been reached already."
      },
      "setCheckpoint(bytes32,uint256)": {
        "notice": "Sets the checkpoints."
      },
      "triggerCheckpoint(bytes32)": {
        "notice": "Sets the checkpoint to the current block timestamp."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}