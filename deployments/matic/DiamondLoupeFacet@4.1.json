{
  "address": "0xA18eA860465dDa431000B36A95A181c98A09136b",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IForwarderRegistry",
          "name": "forwarderRegistry",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "IllegalInterfaceId",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "NotProxyAdmin",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "functionSelector",
          "type": "bytes4"
        }
      ],
      "name": "facetAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "facetAddress_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facetAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "facetAddresses_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "facet",
          "type": "address"
        }
      ],
      "name": "facetFunctionSelectors",
      "outputs": [
        {
          "internalType": "bytes4[]",
          "name": "facetFunctionSelectors_",
          "type": "bytes4[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facets",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facet",
              "type": "address"
            },
            {
              "internalType": "bytes4[]",
              "name": "selectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct Facet[]",
          "name": "facets_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initDiamondLoupeStorage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1c5a282821c0bb917655c43c49e42a132a99933ba7b3fa928d0e5bf8db05fc4f",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x80b12BD0F1793BF6CEa767Fa83Eb2068eaa17DC8",
    "contractAddress": null,
    "transactionIndex": 37,
    "gasUsed": "887100",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000008000000000000000000000000000000000000000000000000000000000800000000000000000080100000000000000000000000000000000000000000000000000000000000080000000000000040000000000000000000000000000000000000000000000040000000000000000200000000000004000000000000000000000000000000000000000000000004000000000000000000011000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x091ff0771bca299242630eded709d577312dfcd79ca156666ad5a00c5c01eec4",
    "transactionHash": "0x1c5a282821c0bb917655c43c49e42a132a99933ba7b3fa928d0e5bf8db05fc4f",
    "logs": [
      {
        "transactionIndex": 37,
        "blockNumber": 69464093,
        "transactionHash": "0x1c5a282821c0bb917655c43c49e42a132a99933ba7b3fa928d0e5bf8db05fc4f",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000080b12bd0f1793bf6cea767fa83eb2068eaa17dc8",
          "0x000000000000000000000000a8b52f02108aa5f4b675bdcc973760022d7c6020"
        ],
        "data": "0x000000000000000000000000000000000000000000000000005e8c61e965f1180000000000000000000000000000000000000000000000063fceac5e63f014cd00000000000000000000000000000000000000000000006b1fc743cce92da8140000000000000000000000000000000000000000000000063f701ffc7a8a23b500000000000000000000000000000000000000000000006b2025d02ed293992c",
        "logIndex": 149,
        "blockHash": "0x091ff0771bca299242630eded709d577312dfcd79ca156666ad5a00c5c01eec4"
      }
    ],
    "blockNumber": 69464093,
    "cumulativeGasUsed": "6170105",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x316a472D084489CB6d4C66e5eB62aE3AdA17521e"
  ],
  "numDeployments": 1,
  "solcInputHash": "84bab0eb3356c2e3bedca0f2f5a163c5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IForwarderRegistry\",\"name\":\"forwarderRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IllegalInterfaceId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NotProxyAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"facetFunctionSelectors_\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDiamondLoupeStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"See https://eips.ethereum.org/EIPS/eip-2535Note: This facet depends on {ProxyAdminFacet} and {InterfaceDetectionFacet}.\",\"errors\":{\"NotProxyAdmin(address)\":[{\"params\":{\"account\":\"The account that was checked.\"}}]},\"kind\":\"dev\",\"methods\":{\"facetAddress(bytes4)\":{\"params\":{\"functionSelector\":\"The function selector.\"},\"returns\":{\"facetAddress_\":\"The facet address that supports `functionSelector`, or the zero address if the facet is not found.\"}},\"facetAddresses()\":{\"returns\":{\"facetAddresses_\":\"The facet addresses used by the diamond.\"}},\"facetFunctionSelectors(address)\":{\"params\":{\"facetAddress\":\"The facet address.\"},\"returns\":{\"facetFunctionSelectors_\":\"The function selectors supported by `facet`.\"}},\"facets()\":{\"returns\":{\"facets_\":\"The facet addresses used by the diamond and their function selectors.\"}},\"initDiamondLoupeStorage()\":{\"details\":\"Reverts with {NotProxyAdmin} if the sender is not the proxy admin.\"}},\"title\":\"Diamond Loupe (facet version).\",\"version\":1},\"userdoc\":{\"errors\":{\"IllegalInterfaceId()\":[{\"notice\":\"Thrown when setting the illegal interfaceId 0xffffffff.\"}],\"NotProxyAdmin(address)\":[{\"notice\":\"Thrown when an account is not the proxy admin but is required to.\"}]},\"kind\":\"user\",\"methods\":{\"facetAddress(bytes4)\":{\"notice\":\"Gets the facet address that supports a given function selector.\"},\"facetAddresses()\":{\"notice\":\"Get all the facet addresses used by the diamond.\"},\"facetFunctionSelectors(address)\":{\"notice\":\"Gets all the function selectors supported by a facet.\"},\"facets()\":{\"notice\":\"Gets all the facet addresses used by the diamond and their function selectors.\"},\"initDiamondLoupeStorage()\":{\"notice\":\"Marks the following ERC165 interface(s) as supported: DiamondLoupe.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/diamond/facets/DiamondLoupeFacet.sol\":\"DiamondLoupeFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":99999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"contracts/diamond/DiamondCommon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\npragma experimental ABIEncoderV2;\\n\\nstruct Facet {\\n    address facet;\\n    bytes4[] selectors;\\n}\\n\\nenum FacetCutAction {\\n    ADD,\\n    REPLACE,\\n    REMOVE\\n}\\n// Add=0, Replace=1, Remove=2\\n\\nstruct FacetCut {\\n    address facet;\\n    FacetCutAction action;\\n    bytes4[] selectors;\\n}\\n\\nstruct Initialization {\\n    address target;\\n    bytes data;\\n}\\n\",\"keccak256\":\"0x0d64b17766734d3804bd731f679ee7db33c77ce1401d55a03ba4e49ec3edc64a\",\"license\":\"MIT\"},\"contracts/diamond/errors/DiamondErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when trying to cut (add/replace/remove) a facet with no function selectors.\\n/// @param facet The facet address.\\nerror EmptyFacet(address facet);\\n\\n/// @notice Thrown when trying to add or replace a facet which is not a deployed contract.\\n/// @param facet The facet address.\\nerror NonContractFacet(address facet);\\n\\n/// @notice Thrown when trying to add a function selector that has already been added.\\n/// @param facet The facet address which already has the function.\\n/// @param selector The function selector which has already been added.\\nerror FunctionAlreadyPresent(address facet, bytes4 selector);\\n\\n/// @notice Thrown when trying to remove function selectors with a non-zero facet address.\\n/// @param facet The facet address which is not zero.\\nerror RemovingWithNonZeroAddressFacet(address facet);\\n\\n/// @notice Thrown when trying to execute, remove or replace a function selector that has not been added.\\n/// @param selector The function selector which has not been added.\\nerror FunctionNotFound(bytes4 selector);\\n\\n/// @notice Thrown when trying to remove or replace an immutable function.\\n/// @param selector The function selector which is immutable.\\nerror ModifyingImmutableFunction(bytes4 selector);\\n\\n/// @notice Thrown when trying to replace a function with itself (from the same facet).\\n/// @param facet The facet address.\\n/// @param selector The function selector.\\nerror ReplacingFunctionByItself(address facet, bytes4 selector);\\n\\n/// @notice Thrown when trying to call an initialization function with a zero address target and non-empty data.\\nerror ZeroAddressTargetInitCallButNonEmptyData();\\n\\n/// @notice Thrown when trying to call an initialization function with a target and empty data.\\n/// @param target The target address for the initialization call.\\nerror EmptyInitCallData(address target);\\n\\n/// @notice Thrown when trying to call an initialization function on a non-contract address.\\n/// @param target The target address for the initialization call.\\nerror NonContractInitCallTarget(address target);\\n\\n/// @notice Thrown when trying to call an initialization function which reverts without return data.\\n/// @param target The target address for the initialization call.\\n/// @param data The data for the initialization call.\\nerror InitCallReverted(address target, bytes data);\\n\",\"keccak256\":\"0x9ff86ca6ac68e852617fb73185f7d87e14e368be00dd30d27d7fa1cbfe3cf8ad\",\"license\":\"MIT\"},\"contracts/diamond/events/DiamondCutEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\npragma experimental ABIEncoderV2;\\n\\nimport {FacetCut} from \\\"./../DiamondCommon.sol\\\";\\n\\n/// @notice Emitted when at least a cut action is operated on the diamond.\\n/// @param cuts The list of facet addresses, actions and function selectors applied to the diamond.\\n/// @param target The address of the contract where `data` was executed.\\n/// @param data The encoded function call executed on `target`.\\nevent DiamondCut(FacetCut[] cuts, address target, bytes data);\\n\",\"keccak256\":\"0x8916f5e60ae1f20b6c2e7ea5046b3f3d89c9f2f2bae1f738671fb20eac23467e\",\"license\":\"MIT\"},\"contracts/diamond/facets/DiamondLoupeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.28;\\npragma experimental ABIEncoderV2;\\n\\nimport {Facet} from \\\"./../DiamondCommon.sol\\\";\\nimport {IForwarderRegistry} from \\\"./../../metatx/interfaces/IForwarderRegistry.sol\\\";\\nimport {IDiamondLoupe} from \\\"./../interfaces/IDiamondLoupe.sol\\\";\\nimport {DiamondStorage} from \\\"./../libraries/DiamondStorage.sol\\\";\\nimport {ProxyAdminStorage} from \\\"./../../proxy/libraries/ProxyAdminStorage.sol\\\";\\nimport {ForwarderRegistryContextBase} from \\\"./../../metatx/base/ForwarderRegistryContextBase.sol\\\";\\n\\n/// @title Diamond Loupe (facet version).\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2535\\n/// @dev Note: This facet depends on {ProxyAdminFacet} and {InterfaceDetectionFacet}.\\ncontract DiamondLoupeFacet is IDiamondLoupe, ForwarderRegistryContextBase {\\n    using ProxyAdminStorage for ProxyAdminStorage.Layout;\\n    using DiamondStorage for DiamondStorage.Layout;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) ForwarderRegistryContextBase(forwarderRegistry) {}\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: DiamondLoupe.\\n    /// @dev Reverts with {NotProxyAdmin} if the sender is not the proxy admin.\\n    function initDiamondLoupeStorage() external {\\n        ProxyAdminStorage.layout().enforceIsProxyAdmin(_msgSender());\\n        DiamondStorage.initDiamondLoupe();\\n    }\\n\\n    /// @inheritdoc IDiamondLoupe\\n    function facets() external view returns (Facet[] memory facets_) {\\n        facets_ = DiamondStorage.layout().facets();\\n    }\\n\\n    /// @inheritdoc IDiamondLoupe\\n    function facetFunctionSelectors(address facet) external view returns (bytes4[] memory facetFunctionSelectors_) {\\n        facetFunctionSelectors_ = DiamondStorage.layout().facetFunctionSelectors(facet);\\n    }\\n\\n    /// @inheritdoc IDiamondLoupe\\n    function facetAddresses() external view returns (address[] memory facetAddresses_) {\\n        facetAddresses_ = DiamondStorage.layout().facetAddresses();\\n    }\\n\\n    /// @inheritdoc IDiamondLoupe\\n    function facetAddress(bytes4 functionSelector) external view returns (address facetAddress_) {\\n        facetAddress_ = DiamondStorage.layout().facetAddress(functionSelector);\\n    }\\n}\\n\",\"keccak256\":\"0x7e0b595b68a5984542db57ca4af4ed98126c145c1f037e7e49d776188038b7ad\",\"license\":\"MIT\"},\"contracts/diamond/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\npragma experimental ABIEncoderV2;\\n\\nimport {FacetCut} from \\\"./../DiamondCommon.sol\\\";\\n\\n/// @title ERC2535 Diamond Standard, Diamond Cut (functions).\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2535\\n/// @dev Note: the ERC-165 identifier for this interface is 0x1f931c1c\\ninterface IDiamondCut {\\n    /// @notice Add/replace/remove facet functions and optionally execute a function with delegatecall.\\n    /// @dev Emits a {DiamondCut} event.\\n    /// @param cuts The list of facet addresses, actions and function selectors to apply to the diamond.\\n    /// @param target The address of the contract to execute `data` on.\\n    /// @param data The encoded function call to execute on `target`.\\n    function diamondCut(FacetCut[] calldata cuts, address target, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0x96e2a77e98f8126bacae21e354af6bbea2f9e55fae71904bb4a33d6c6423379f\",\"license\":\"MIT\"},\"contracts/diamond/interfaces/IDiamondCutBatchInit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\npragma experimental ABIEncoderV2;\\n\\nimport {FacetCut, Initialization} from \\\"./../DiamondCommon.sol\\\";\\n\\n/// @title ERCXXX Diamond Standard, Diamond Cut Batch Init extension.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-XXXX\\n/// @dev Note: the ERC-165 identifier for this interface is 0xb2afc5b5\\ninterface IDiamondCutBatchInit {\\n    /// @notice Add/replace/remove facet functions and execute a batch of functions with delegatecall.\\n    /// @dev Emits a {DiamondCut} event.\\n    /// @param cuts The list of facet addresses, actions and function selectors to apply to the diamond.\\n    /// @param initializations The list of addresses and encoded function calls to execute with delegatecall.\\n    function diamondCut(FacetCut[] calldata cuts, Initialization[] calldata initializations) external;\\n}\\n\",\"keccak256\":\"0xe466696aec6c26e1b7040b36467c7eb61695387c4f8ec8fadb05324d15774a7e\",\"license\":\"MIT\"},\"contracts/diamond/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\npragma experimental ABIEncoderV2;\\n\\nimport {Facet} from \\\"./../DiamondCommon.sol\\\";\\n\\n/// @title ERC2535 Diamond Standard, Diamond Loupe.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2535\\n/// @dev Note: the ERC-165 identifier for this interface is 0x48e2b093\\ninterface IDiamondLoupe {\\n    /// @notice Gets all the facet addresses used by the diamond and their function selectors.\\n    /// @return diamondFacets The facet addresses used by the diamond and their function selectors.\\n    function facets() external view returns (Facet[] memory diamondFacets);\\n\\n    /// @notice Gets all the function selectors supported by a facet.\\n    /// @param facetAddress The facet address.\\n    /// @return selectors The function selectors supported by `facet`.\\n    function facetFunctionSelectors(address facetAddress) external view returns (bytes4[] memory selectors);\\n\\n    /// @notice Get all the facet addresses used by the diamond.\\n    /// @return diamondFacetsAddresses The facet addresses used by the diamond.\\n    function facetAddresses() external view returns (address[] memory diamondFacetsAddresses);\\n\\n    /// @notice Gets the facet address that supports a given function selector.\\n    /// @param functionSelector The function selector.\\n    /// @return diamondFacetAddress The facet address that supports `functionSelector`, or the zero address if the facet is not found.\\n    function facetAddress(bytes4 functionSelector) external view returns (address diamondFacetAddress);\\n}\\n\",\"keccak256\":\"0xa7072ab2bf2894f2d79b4f1b649ebcbac74b42a972ee048766d796dc263e4f28\",\"license\":\"MIT\"},\"contracts/diamond/libraries/DiamondStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\npragma experimental ABIEncoderV2;\\n\\n// solhint-disable-next-line max-line-length\\nimport {EmptyFacet, NonContractFacet, FunctionAlreadyPresent, RemovingWithNonZeroAddressFacet, FunctionNotFound, ModifyingImmutableFunction, ReplacingFunctionByItself, ZeroAddressTargetInitCallButNonEmptyData, EmptyInitCallData, NonContractInitCallTarget, InitCallReverted} from \\\"./../errors/DiamondErrors.sol\\\";\\nimport {Facet, FacetCutAction, FacetCut, Initialization} from \\\"./../DiamondCommon.sol\\\";\\nimport {DiamondCut} from \\\"./../events/DiamondCutEvents.sol\\\";\\nimport {IDiamondCut} from \\\"./../interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondCutBatchInit} from \\\"./../interfaces/IDiamondCutBatchInit.sol\\\";\\nimport {IDiamondLoupe} from \\\"./../interfaces/IDiamondLoupe.sol\\\";\\nimport {Address} from \\\"./../../utils/libraries/Address.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./../../introspection/libraries/InterfaceDetectionStorage.sol\\\";\\n\\n/// @dev derived from https://github.com/mudgen/diamond-2 (MIT licence) and https://github.com/solidstate-network/solidstate-solidity (MIT licence)\\nlibrary DiamondStorage {\\n    using Address for address;\\n    using DiamondStorage for DiamondStorage.Layout;\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n\\n    struct Layout {\\n        // selector => (facet address, selector slot position)\\n        mapping(bytes4 => bytes32) diamondFacets;\\n        // number of selectors registered in selectorSlots\\n        uint16 selectorCount;\\n        // array of selector slots with 8 selectors per slot\\n        mapping(uint256 => bytes32) selectorSlots;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.Diamond.storage\\\")) - 1);\\n\\n    bytes32 internal constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 internal constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: DiamondCut, DiamondCutBatchInit.\\n    function initDiamondCut() internal {\\n        InterfaceDetectionStorage.Layout storage interfaceDetectionLayout = InterfaceDetectionStorage.layout();\\n        interfaceDetectionLayout.setSupportedInterface(type(IDiamondCut).interfaceId, true);\\n        interfaceDetectionLayout.setSupportedInterface(type(IDiamondCutBatchInit).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: DiamondLoupe.\\n    function initDiamondLoupe() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IDiamondLoupe).interfaceId, true);\\n    }\\n\\n    function diamondCut(Layout storage s, FacetCut[] memory cuts, address target, bytes memory data) internal {\\n        s.cutFacets(cuts);\\n        initializationCall(target, data);\\n        emit DiamondCut(cuts, target, data);\\n    }\\n\\n    function diamondCut(Layout storage s, FacetCut[] memory cuts, Initialization[] memory initializations) internal {\\n        s.cutFacets(cuts);\\n        uint256 length = initializations.length;\\n        for (uint256 i; i < length; ++i) {\\n            initializationCall(initializations[i].target, initializations[i].data);\\n        }\\n        emit DiamondCut(cuts, address(0), \\\"\\\");\\n    }\\n\\n    function cutFacets(Layout storage s, FacetCut[] memory facetCuts) internal {\\n        uint256 originalSelectorCount = s.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n\\n        // Check if last selector slot is not full\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\\n        }\\n\\n        uint256 length = facetCuts.length;\\n        for (uint256 i; i < length; ++i) {\\n            FacetCut memory facetCut = facetCuts[i];\\n\\n            if (facetCut.selectors.length == 0) revert EmptyFacet(facetCut.facet);\\n\\n            FacetCutAction action = facetCut.action;\\n            if (action == FacetCutAction.ADD) {\\n                (selectorCount, selectorSlot) = s.addFacetSelectors(selectorCount, selectorSlot, facetCut);\\n            } else if (action == FacetCutAction.REPLACE) {\\n                s.replaceFacetSelectors(facetCut);\\n            } else {\\n                (selectorCount, selectorSlot) = s.removeFacetSelectors(selectorCount, selectorSlot, facetCut);\\n            }\\n        }\\n\\n        if (selectorCount != originalSelectorCount) {\\n            s.selectorCount = uint16(selectorCount);\\n        }\\n\\n        // If last selector slot is not full\\n        if (selectorCount & 7 > 0) {\\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n    }\\n\\n    function addFacetSelectors(\\n        Layout storage s,\\n        uint256 selectorCount,\\n        bytes32 selectorSlot,\\n        FacetCut memory facetCut\\n    ) internal returns (uint256, bytes32) {\\n        if (facetCut.facet != address(this) && !facetCut.facet.hasBytecode()) revert NonContractFacet(facetCut.facet);\\n\\n        uint256 length = facetCut.selectors.length;\\n        for (uint256 i; i < length; ++i) {\\n            bytes4 selector = facetCut.selectors[i];\\n            address oldFacetAddress = address(bytes20(s.diamondFacets[selector]));\\n\\n            if (oldFacetAddress != address(0)) revert FunctionAlreadyPresent(oldFacetAddress, selector);\\n\\n            // add facet for selector\\n            s.diamondFacets[selector] = bytes20(facetCut.facet) | bytes32(selectorCount);\\n            uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\\n\\n            // clear selector position in slot and add selector\\n            selectorSlot = (selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\\n\\n            // if slot is full then write it to storage\\n            if (selectorInSlotPosition == 224) {\\n                s.selectorSlots[selectorCount >> 3] = selectorSlot;\\n                selectorSlot = 0;\\n            }\\n\\n            unchecked {\\n                ++selectorCount;\\n            }\\n        }\\n\\n        return (selectorCount, selectorSlot);\\n    }\\n\\n    function removeFacetSelectors(\\n        Layout storage s,\\n        uint256 selectorCount,\\n        bytes32 selectorSlot,\\n        FacetCut memory facetCut\\n    ) internal returns (uint256, bytes32) {\\n        if (facetCut.facet != address(0)) revert RemovingWithNonZeroAddressFacet(facetCut.facet);\\n\\n        uint256 selectorSlotCount = selectorCount >> 3;\\n        uint256 selectorInSlotIndex = selectorCount & 7;\\n\\n        for (uint256 i; i < facetCut.selectors.length; ++i) {\\n            bytes4 selector = facetCut.selectors[i];\\n            bytes32 oldFacet = s.diamondFacets[selector];\\n\\n            if (address(bytes20(s.diamondFacets[selector])) == address(0)) revert FunctionNotFound(selector);\\n            if (address(bytes20(s.diamondFacets[selector])) == address(this)) revert ModifyingImmutableFunction(selector);\\n\\n            if (selectorSlot == 0) {\\n                unchecked {\\n                    selectorSlotCount--;\\n                }\\n                selectorSlot = s.selectorSlots[selectorSlotCount];\\n                selectorInSlotIndex = 7;\\n            } else {\\n                unchecked {\\n                    selectorInSlotIndex--;\\n                }\\n            }\\n\\n            bytes4 lastSelector;\\n            uint256 oldSelectorsSlotCount;\\n            uint256 oldSelectorInSlotPosition;\\n\\n            // adding a block here prevents stack too deep error\\n            {\\n                // replace selector with last selector in l.facets\\n                lastSelector = bytes4(selectorSlot << (selectorInSlotIndex << 5));\\n\\n                if (lastSelector != selector) {\\n                    // update last selector slot position info\\n                    s.diamondFacets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(s.diamondFacets[lastSelector]);\\n                }\\n\\n                delete s.diamondFacets[selector];\\n                uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n            }\\n\\n            if (oldSelectorsSlotCount != selectorSlotCount) {\\n                bytes32 oldSelectorSlot = s.selectorSlots[oldSelectorsSlotCount];\\n\\n                // clears the selector we are deleting and puts the last selector in its place.\\n                oldSelectorSlot =\\n                    (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                    (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                // update storage with the modified slot\\n                s.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n            } else {\\n                // clears the selector we are deleting and puts the last selector in its place.\\n                selectorSlot =\\n                    (selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                    (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n            }\\n\\n            if (selectorInSlotIndex == 0) {\\n                delete s.selectorSlots[selectorSlotCount];\\n                selectorSlot = 0;\\n            }\\n        }\\n\\n        selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\\n\\n        return (selectorCount, selectorSlot);\\n    }\\n\\n    function replaceFacetSelectors(Layout storage s, FacetCut memory facetCut) internal {\\n        address facet = facetCut.facet;\\n        if (!facet.hasBytecode()) revert NonContractFacet(facetCut.facet);\\n\\n        uint256 length = facetCut.selectors.length;\\n        for (uint256 i; i < length; ++i) {\\n            bytes4 selector = facetCut.selectors[i];\\n            bytes32 oldFacet = s.diamondFacets[selector];\\n            address oldFacetAddress = address(bytes20(oldFacet));\\n\\n            if (oldFacetAddress == address(0)) revert FunctionNotFound(selector);\\n            if (oldFacetAddress == address(this)) revert ModifyingImmutableFunction(selector);\\n            if (oldFacetAddress == facet) revert ReplacingFunctionByItself(facet, selector);\\n\\n            // replace old facet address\\n            s.diamondFacets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(facet);\\n        }\\n    }\\n\\n    function initializationCall(address target, bytes memory data) internal {\\n        if (target == address(0)) {\\n            if (data.length != 0) revert ZeroAddressTargetInitCallButNonEmptyData();\\n        } else {\\n            if (data.length == 0) revert EmptyInitCallData(target);\\n            if (target != address(this)) {\\n                if (!target.hasBytecode()) revert NonContractInitCallTarget(target);\\n            }\\n\\n            (bool success, bytes memory returndata) = target.delegatecall(data);\\n            if (!success) {\\n                uint256 returndataLength = returndata.length;\\n                if (returndataLength != 0) {\\n                    assembly {\\n                        revert(add(32, returndata), returndataLength)\\n                    }\\n                } else {\\n                    revert InitCallReverted(target, data);\\n                }\\n            }\\n        }\\n    }\\n\\n    function delegateOnFallback(Layout storage s) internal {\\n        bytes4 selector = msg.sig;\\n        address facet = s.facetAddress(selector);\\n        if (facet == address(0)) revert FunctionNotFound(selector);\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function facets(Layout storage s) internal view returns (Facet[] memory diamondFacets) {\\n        unchecked {\\n            uint16 selectorCount = s.selectorCount;\\n            diamondFacets = new Facet[](selectorCount);\\n\\n            uint256[] memory numFacetSelectors = new uint256[](selectorCount);\\n            uint256 numFacets;\\n            uint256 selectorIndex;\\n\\n            // loop through function selectors\\n            for (uint256 slotIndex; selectorIndex < selectorCount; ++slotIndex) {\\n                bytes32 slot = s.selectorSlots[slotIndex];\\n\\n                for (uint256 selectorSlotIndex; selectorSlotIndex != 8; ++selectorSlotIndex) {\\n                    ++selectorIndex;\\n\\n                    if (selectorIndex > selectorCount) {\\n                        break;\\n                    }\\n\\n                    bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n                    address facet = address(bytes20(s.diamondFacets[selector]));\\n\\n                    bool continueLoop;\\n\\n                    for (uint256 facetIndex; facetIndex != numFacets; ++facetIndex) {\\n                        if (diamondFacets[facetIndex].facet == facet) {\\n                            diamondFacets[facetIndex].selectors[numFacetSelectors[facetIndex]] = selector;\\n                            ++numFacetSelectors[facetIndex];\\n                            continueLoop = true;\\n                            break;\\n                        }\\n                    }\\n\\n                    if (continueLoop) {\\n                        continue;\\n                    }\\n\\n                    diamondFacets[numFacets].facet = facet;\\n                    diamondFacets[numFacets].selectors = new bytes4[](selectorCount);\\n                    diamondFacets[numFacets].selectors[0] = selector;\\n                    numFacetSelectors[numFacets] = 1;\\n                    ++numFacets;\\n                }\\n            }\\n\\n            for (uint256 facetIndex; facetIndex < numFacets; ++facetIndex) {\\n                uint256 numSelectors = numFacetSelectors[facetIndex];\\n                bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\\n\\n                // setting the number of selectors\\n                assembly {\\n                    mstore(selectors, numSelectors)\\n                }\\n            }\\n\\n            // setting the number of facets\\n            assembly {\\n                mstore(diamondFacets, numFacets)\\n            }\\n        }\\n    }\\n\\n    function facetFunctionSelectors(Layout storage s, address facet) internal view returns (bytes4[] memory selectors) {\\n        unchecked {\\n            uint16 selectorCount = s.selectorCount;\\n            selectors = new bytes4[](selectorCount);\\n\\n            uint256 numSelectors;\\n            uint256 selectorIndex;\\n\\n            // loop through function selectors\\n            for (uint256 slotIndex; selectorIndex < selectorCount; ++slotIndex) {\\n                bytes32 slot = s.selectorSlots[slotIndex];\\n\\n                for (uint256 selectorSlotIndex; selectorSlotIndex != 8; ++selectorSlotIndex) {\\n                    ++selectorIndex;\\n\\n                    if (selectorIndex > selectorCount) {\\n                        break;\\n                    }\\n\\n                    bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n\\n                    if (facet == address(bytes20(s.diamondFacets[selector]))) {\\n                        selectors[numSelectors] = selector;\\n                        ++numSelectors;\\n                    }\\n                }\\n            }\\n\\n            // set the number of selectors in the array\\n            assembly {\\n                mstore(selectors, numSelectors)\\n            }\\n        }\\n    }\\n\\n    function facetAddresses(Layout storage s) internal view returns (address[] memory addresses) {\\n        unchecked {\\n            uint16 selectorCount = s.selectorCount;\\n            addresses = new address[](selectorCount);\\n            uint256 numFacets;\\n            uint256 selectorIndex;\\n\\n            for (uint256 slotIndex; selectorIndex < selectorCount; ++slotIndex) {\\n                bytes32 slot = s.selectorSlots[slotIndex];\\n\\n                for (uint256 selectorSlotIndex; selectorSlotIndex != 8; ++selectorSlotIndex) {\\n                    ++selectorIndex;\\n\\n                    if (selectorIndex > selectorCount) {\\n                        break;\\n                    }\\n\\n                    bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n                    address facet = address(bytes20(s.diamondFacets[selector]));\\n\\n                    bool continueLoop;\\n\\n                    for (uint256 facetIndex; facetIndex < numFacets; ++facetIndex) {\\n                        if (facet == addresses[facetIndex]) {\\n                            continueLoop = true;\\n                            break;\\n                        }\\n                    }\\n\\n                    if (continueLoop) {\\n                        continue;\\n                    }\\n\\n                    addresses[numFacets] = facet;\\n                    ++numFacets;\\n                }\\n            }\\n\\n            // set the number of facet addresses in the array\\n            assembly {\\n                mstore(addresses, numFacets)\\n            }\\n        }\\n    }\\n\\n    function facetAddress(Layout storage s, bytes4 selector) internal view returns (address facet) {\\n        facet = address(bytes20(s.diamondFacets[selector]));\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x43f33d038ea2b42f8ba0c44d5d5e6981b4d5eb16c05f53410a119d3b17496936\",\"license\":\"MIT\"},\"contracts/introspection/errors/InterfaceDetectionErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when setting the illegal interfaceId 0xffffffff.\\nerror IllegalInterfaceId();\\n\",\"keccak256\":\"0x0fd7df6f16ddbcaf3f5b8f603a12c0516e1dc5ee08eb770da52691adf070e0bd\",\"license\":\"MIT\"},\"contracts/introspection/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC165 Interface Detection Standard.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-165.\\n/// @dev Note: The ERC-165 identifier for this interface is 0x01ffc9a7.\\ninterface IERC165 {\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId the interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool supported);\\n}\\n\",\"keccak256\":\"0x34f460e915aaaec82d62c228f4813ca758b487034eaa43b65c128389539194d9\",\"license\":\"MIT\"},\"contracts/introspection/libraries/InterfaceDetectionStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IllegalInterfaceId} from \\\"./../errors/InterfaceDetectionErrors.sol\\\";\\nimport {IERC165} from \\\"./../interfaces/IERC165.sol\\\";\\n\\nlibrary InterfaceDetectionStorage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.introspection.InterfaceDetection.storage\\\")) - 1);\\n\\n    bytes4 internal constant ILLEGAL_INTERFACE_ID = 0xffffffff;\\n\\n    /// @notice Sets or unsets an ERC165 interface.\\n    /// @dev Revertswith {IllegalInterfaceId} if `interfaceId` is `0xffffffff`.\\n    /// @param interfaceId the interface identifier.\\n    /// @param supported True to set the interface, false to unset it.\\n    function setSupportedInterface(Layout storage s, bytes4 interfaceId, bool supported) internal {\\n        if (interfaceId == ILLEGAL_INTERFACE_ID) revert IllegalInterfaceId();\\n        s.supportedInterfaces[interfaceId] = supported;\\n    }\\n\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId The interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(Layout storage s, bytes4 interfaceId) internal view returns (bool supported) {\\n        if (interfaceId == ILLEGAL_INTERFACE_ID) {\\n            return false;\\n        }\\n        if (interfaceId == type(IERC165).interfaceId) {\\n            return true;\\n        }\\n        return s.supportedInterfaces[interfaceId];\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeaf559662562be7885b75193ff6994e52cf8109c898ffced02c2b26785d94ee2\",\"license\":\"MIT\"},\"contracts/metatx/base/ForwarderRegistryContextBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IForwarderRegistry} from \\\"./../interfaces/IForwarderRegistry.sol\\\";\\nimport {ERC2771Calldata} from \\\"./../libraries/ERC2771Calldata.sol\\\";\\n\\n/// @title Meta-Transactions Forwarder Registry Context (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Derived from https://github.com/wighawag/universal-forwarder (MIT licence)\\nabstract contract ForwarderRegistryContextBase {\\n    IForwarderRegistry internal immutable _FORWARDER_REGISTRY;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) {\\n        _FORWARDER_REGISTRY = forwarderRegistry;\\n    }\\n\\n    /// @notice Returns the message sender depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgSender() internal view virtual returns (address) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.sender;\\n        }\\n\\n        address sender = ERC2771Calldata.msgSender();\\n\\n        // Return the EIP-2771 calldata-appended sender address if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (msg.sender == address(_FORWARDER_REGISTRY) || _FORWARDER_REGISTRY.isApprovedForwarder(sender, msg.sender, address(this))) {\\n            return sender;\\n        }\\n\\n        return msg.sender;\\n    }\\n\\n    /// @notice Returns the message data depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.data;\\n        }\\n\\n        // Return the EIP-2771 calldata (minus the appended sender) if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (\\n            msg.sender == address(_FORWARDER_REGISTRY) ||\\n            _FORWARDER_REGISTRY.isApprovedForwarder(ERC2771Calldata.msgSender(), msg.sender, address(this))\\n        ) {\\n            return ERC2771Calldata.msgData();\\n        }\\n\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x9a024b7aa6527471d6a097c62dfa94e85a1427ec63776153aff9e5d7ba229040\",\"license\":\"MIT\"},\"contracts/metatx/interfaces/IForwarderRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title Meta-Transactions Forwarder Registry.\\ninterface IForwarderRegistry {\\n    /// @notice Checks whether an account is as an approved meta-transaction forwarder for a sender account to a target contract.\\n    /// @param sender The sender account.\\n    /// @param forwarder The forwarder account.\\n    /// @param target The target contract.\\n    /// @return isApproved True if `forwarder` is an approved meta-transaction forwarder for `sender` to `target`, false otherwise.\\n    function isApprovedForwarder(address sender, address forwarder, address target) external view returns (bool isApproved);\\n}\\n\",\"keccak256\":\"0xdfb17430660876a9214c0cc4c37eb688c565b3c8211151b3413d88d5b4e4c4cb\",\"license\":\"MIT\"},\"contracts/metatx/libraries/ERC2771Calldata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @dev Derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT licence)\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2771\\nlibrary ERC2771Calldata {\\n    /// @notice Returns the sender address appended at the end of the calldata, as specified in EIP-2771.\\n    function msgSender() internal pure returns (address sender) {\\n        assembly {\\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n    /// @notice Returns the calldata while omitting the appended sender address, as specified in EIP-2771.\\n    function msgData() internal pure returns (bytes calldata data) {\\n        unchecked {\\n            return msg.data[:msg.data.length - 20];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8de5057207aa02ba450c95d802f3f77736cafeb1c4e516d6989c27ff5fa1315d\",\"license\":\"MIT\"},\"contracts/proxy/errors/ProxyAdminErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when the initial admin is not set.\\nerror NoInitialProxyAdmin();\\n\\n/// @notice Thrown when an account is not the proxy admin but is required to.\\n/// @param account The account that was checked.\\nerror NotProxyAdmin(address account);\\n\",\"keccak256\":\"0x8ba37d9f154407fc3ddc058b5f678866b274a9674cd850bd8bf73d79e626c160\",\"license\":\"MIT\"},\"contracts/proxy/errors/ProxyInitializationErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when trying to set a phase value that has already been reached.\\n/// @param currentPhase The current phase.\\n/// @param newPhase The new phase trying to be set.\\nerror InitializationPhaseAlreadyReached(uint256 currentPhase, uint256 newPhase);\\n\",\"keccak256\":\"0x85ee7912d0020d0f032e2dacacbec057114235fbdab703753fdcde5c78275543\",\"license\":\"MIT\"},\"contracts/proxy/events/ProxyAdminEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when the proxy admin changes.\\n/// @param previousAdmin the previous admin.\\n/// @param newAdmin the new admin.\\nevent AdminChanged(address previousAdmin, address newAdmin);\\n\",\"keccak256\":\"0x8af172a87e9b4f1188e7837f4aaac8bdb438191b1465cc963f4543da1a435476\",\"license\":\"MIT\"},\"contracts/proxy/libraries/ProxyAdminStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {NoInitialProxyAdmin, NotProxyAdmin} from \\\"./../errors/ProxyAdminErrors.sol\\\";\\nimport {AdminChanged} from \\\"./../events/ProxyAdminEvents.sol\\\";\\nimport {ProxyInitialization} from \\\"./ProxyInitialization.sol\\\";\\n\\nlibrary ProxyAdminStorage {\\n    using ProxyAdminStorage for ProxyAdminStorage.Layout;\\n\\n    struct Layout {\\n        address admin;\\n    }\\n\\n    // bytes32 public constant PROXYADMIN_STORAGE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n    bytes32 internal constant PROXY_INIT_PHASE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin.phase\\\")) - 1);\\n\\n    /// @notice Initializes the storage with an initial admin (immutable version).\\n    /// @dev Note: This function should be called ONLY in the constructor of an immutable (non-proxied) contract.\\n    /// @dev Reverts {NoInitialProxyAdmin} if `initialAdmin` is the zero address.\\n    /// @dev Emits an {AdminChanged} event.\\n    /// @param initialAdmin The initial payout wallet.\\n    function constructorInit(Layout storage s, address initialAdmin) internal {\\n        if (initialAdmin == address(0)) revert NoInitialProxyAdmin();\\n        s.admin = initialAdmin;\\n        emit AdminChanged(address(0), initialAdmin);\\n    }\\n\\n    /// @notice Initializes the storage with an initial admin (proxied version).\\n    /// @notice Sets the proxy initialization phase to `1`.\\n    /// @dev Note: This function should be called ONLY in the init function of a proxied contract.\\n    /// @dev Reverts with {InitializationPhaseAlreadyReached} if the proxy initialization phase is set to `1` or above.\\n    /// @dev Reverts {NoInitialProxyAdmin} if `initialAdmin` is the zero address.\\n    /// @dev Emits an {AdminChanged} event.\\n    /// @param initialAdmin The initial payout wallet.\\n    function proxyInit(Layout storage s, address initialAdmin) internal {\\n        ProxyInitialization.setPhase(PROXY_INIT_PHASE_SLOT, 1);\\n        s.constructorInit(initialAdmin);\\n    }\\n\\n    /// @notice Sets a new proxy admin.\\n    /// @dev Reverts with {NotProxyAdmin} if `sender` is not the proxy admin.\\n    /// @dev Emits an {AdminChanged} event if `newAdmin` is different from the current proxy admin.\\n    /// @param newAdmin The new proxy admin.\\n    function changeProxyAdmin(Layout storage s, address sender, address newAdmin) internal {\\n        address previousAdmin = s.admin;\\n        if (sender != previousAdmin) revert NotProxyAdmin(sender);\\n        if (previousAdmin != newAdmin) {\\n            s.admin = newAdmin;\\n            emit AdminChanged(previousAdmin, newAdmin);\\n        }\\n    }\\n\\n    /// @notice Gets the proxy admin.\\n    /// @return admin The proxy admin\\n    function proxyAdmin(Layout storage s) internal view returns (address admin) {\\n        return s.admin;\\n    }\\n\\n    /// @notice Ensures that an account is the proxy admin.\\n    /// @dev Reverts with {NotProxyAdmin} if `account` is not the proxy admin.\\n    /// @param account The account.\\n    function enforceIsProxyAdmin(Layout storage s, address account) internal view {\\n        if (account != s.admin) revert NotProxyAdmin(account);\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1f1cb9a6470f14aa9942dedd288aaffc6c582abf831edeb52e51a3691cdd32a4\",\"license\":\"MIT\"},\"contracts/proxy/libraries/ProxyInitialization.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {InitializationPhaseAlreadyReached} from \\\"./../errors/ProxyInitializationErrors.sol\\\";\\nimport {StorageSlot} from \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n/// @notice Multiple calls protection for storage-modifying proxy initialization functions.\\nlibrary ProxyInitialization {\\n    /// @notice Sets the initialization phase during a storage-modifying proxy initialization function.\\n    /// @dev Reverts with {InitializationPhaseAlreadyReached} if `phase` has been reached already.\\n    /// @param storageSlot the storage slot where `phase` is stored.\\n    /// @param phase the initialization phase.\\n    function setPhase(bytes32 storageSlot, uint256 phase) internal {\\n        StorageSlot.Uint256Slot storage currentVersion = StorageSlot.getUint256Slot(storageSlot);\\n        uint256 currentPhase = currentVersion.value;\\n        if (currentPhase >= phase) revert InitializationPhaseAlreadyReached(currentPhase, phase);\\n        currentVersion.value = phase;\\n    }\\n}\\n\",\"keccak256\":\"0xdc2cca29702fe573cb5af8c3320eafe7a490aef99bcaafe1e6575159bb0007d7\",\"license\":\"MIT\"},\"contracts/utils/libraries/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nlibrary Address {\\n    /// @notice Checks if the address is a deployed smart contract.\\n    /// @param addr The address to check.\\n    /// @return hasBytecode True if `addr` is a deployed smart contract, false otherwise.\\n    function hasBytecode(address addr) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size != 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf3119a6298c6da4e7da69344ae8ab51a6a64dc08c68f826a560e72d46cf0ad9c\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a0604052348015600f57600080fd5b50604051610faa380380610faa833981016040819052602c91603c565b6001600160a01b0316608052606a565b600060208284031215604d57600080fd5b81516001600160a01b0381168114606357600080fd5b9392505050565b608051610f1e61008c600039600081816101f1015261027f0152610f1e6000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c80637a0ed627116100505780637a0ed62714610094578063adfca15e146100a9578063cdffacc6146100c957600080fd5b80634fe5dd791461006c57806352ef6b2c14610076575b600080fd5b610074610101565b005b61007e610124565b60405161008b9190610c35565b60405180910390f35b61009c61013b565b60405161008b9190610cec565b6100bc6100b7366004610d9c565b61014d565b60405161008b9190610dd9565b6100dc6100d7366004610dec565b610167565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161008b565b61011a61010c6101ae565b6101146102fb565b90610329565b61012261039c565b565b60606101366101316103d1565b6103ff565b905090565b60606101366101486103d1565b6105b5565b60606101618261015b6103d1565b906109da565b92915050565b6000610161826101756103d1565b907fffffffff00000000000000000000000000000000000000000000000000000000166000908152602091909152604090205460601c90565b6000333214806101be5750601836105b156101c857503390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163314806102ea57506040517f019a202800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301523360248301523060448301527f0000000000000000000000000000000000000000000000000000000000000000169063019a202890606401602060405180830381865afa1580156102c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ea9190610e2e565b156102f457919050565b3391505090565b60008061016160017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104610e50565b815473ffffffffffffffffffffffffffffffffffffffff828116911614610398576040517f673a31a100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8216600482015260240160405180910390fd5b5050565b6101227f48e2b0930000000000000000000000000000000000000000000000000000000060016103ca610b2b565b9190610b59565b60008061016160017f65d27473a5b05206737961f69a3b7a55316862d7a6ef82b3f5455fe92fab43e3610e50565b600181015460609061ffff168067ffffffffffffffff81111561042457610424610e8a565b60405190808252806020026020018201604052801561044d578160200160208202803683370190505b50915060008060005b8361ffff168210156105ab576000818152600287016020526040812054905b806008146105a1578360010193508561ffff1684116105a157600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208a9052604081205460601c90805b88811015610533578a81815181106104e8576104e8610eb9565b602002602001015173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361052b5760019150610533565b6001016104ce565b50801561054257505050610599565b818a898151811061055557610555610eb9565b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508760010197505050505b600101610475565b5050600101610456565b5050825250919050565b600181015460609061ffff168067ffffffffffffffff8111156105da576105da610e8a565b60405190808252806020026020018201604052801561062057816020015b6040805180820190915260008152606060208201528152602001906001900390816105f85790505b50915060008161ffff1667ffffffffffffffff81111561064257610642610e8a565b60405190808252806020026020018201604052801561066b578160200160208202803683370190505b50905060008060005b8461ffff16821015610975576000818152600288016020526040812054905b8060081461096b578360010193508661ffff16841161096b57600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208b9052604081205460601c90805b88811461080d578273ffffffffffffffffffffffffffffffffffffffff168c828151811061071c5761071c610eb9565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff160361080557838c828151811061075657610756610eb9565b6020026020010151602001518b838151811061077457610774610eb9565b60200260200101518151811061078c5761078c610eb9565b60200260200101907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815250508981815181106107ea576107ea610eb9565b6020026020010180516001019081815250506001915061080d565b6001016106ec565b50801561081c57505050610963565b818b898151811061082f5761082f610eb9565b602090810291909101015173ffffffffffffffffffffffffffffffffffffffff909116905261ffff8a1667ffffffffffffffff81111561087157610871610e8a565b60405190808252806020026020018201604052801561089a578160200160208202803683370190505b508b89815181106108ad576108ad610eb9565b602002602001015160200181905250828b89815181106108cf576108cf610eb9565b6020026020010151602001516000815181106108ed576108ed610eb9565b60200260200101907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050600189898151811061094d5761094d610eb9565b6020026020010181815250508760010197505050505b600101610693565b5050600101610674565b5060005b828110156109ce57600084828151811061099557610995610eb9565b6020026020010151905060008783815181106109b3576109b3610eb9565b60209081029190910181015101519190915250600101610979565b50508352509092915050565b600182015460609061ffff168067ffffffffffffffff8111156109ff576109ff610e8a565b604051908082528060200260200182016040528015610a28578160200160208202803683370190505b50915060008060005b8361ffff16821015610b20576000818152600288016020526040812054905b80600814610b16578360010193508561ffff168411610b1657600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208b9052604090205460601c73ffffffffffffffffffffffffffffffffffffffff8a1603610b0d5780888781518110610ad557610ad5610eb9565b7fffffffff00000000000000000000000000000000000000000000000000000000909216602092830291909101909101526001909501945b50600101610a50565b5050600101610a31565b505082525092915050565b60008061016160017fca9d3e17f264b0f3984e2634e94adb37fa3e6a8103f06aeae6fa59e21c769f5e610e50565b7c01000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831601610bd1576040517f72c683bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7fffffffff00000000000000000000000000000000000000000000000000000000919091166000908152602092909252604090912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b602080825282518282018190526000918401906040840190835b81811015610c8357835173ffffffffffffffffffffffffffffffffffffffff16835260209384019390920191600101610c4f565b509095945050505050565b600081518084526020840193506020830160005b82811015610ce25781517fffffffff0000000000000000000000000000000000000000000000000000000016865260209586019590910190600101610ca2565b5093949350505050565b6000602082016020835280845180835260408501915060408160051b86010192506020860160005b82811015610d90577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0878603018452815173ffffffffffffffffffffffffffffffffffffffff81511686526020810151905060406020870152610d7a6040870182610c8e565b9550506020938401939190910190600101610d14565b50929695505050505050565b600060208284031215610dae57600080fd5b813573ffffffffffffffffffffffffffffffffffffffff81168114610dd257600080fd5b9392505050565b602081526000610dd26020830184610c8e565b600060208284031215610dfe57600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610dd257600080fd5b600060208284031215610e4057600080fd5b81518015158114610dd257600080fd5b81810381811115610161577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220de651ced90efc2f452f9294ae379f6d6f2e322f3b94dd983b32f0d89ed6385f764736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100675760003560e01c80637a0ed627116100505780637a0ed62714610094578063adfca15e146100a9578063cdffacc6146100c957600080fd5b80634fe5dd791461006c57806352ef6b2c14610076575b600080fd5b610074610101565b005b61007e610124565b60405161008b9190610c35565b60405180910390f35b61009c61013b565b60405161008b9190610cec565b6100bc6100b7366004610d9c565b61014d565b60405161008b9190610dd9565b6100dc6100d7366004610dec565b610167565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161008b565b61011a61010c6101ae565b6101146102fb565b90610329565b61012261039c565b565b60606101366101316103d1565b6103ff565b905090565b60606101366101486103d1565b6105b5565b60606101618261015b6103d1565b906109da565b92915050565b6000610161826101756103d1565b907fffffffff00000000000000000000000000000000000000000000000000000000166000908152602091909152604090205460601c90565b6000333214806101be5750601836105b156101c857503390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff163314806102ea57506040517f019a202800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301523360248301523060448301527f0000000000000000000000000000000000000000000000000000000000000000169063019a202890606401602060405180830381865afa1580156102c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ea9190610e2e565b156102f457919050565b3391505090565b60008061016160017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104610e50565b815473ffffffffffffffffffffffffffffffffffffffff828116911614610398576040517f673a31a100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8216600482015260240160405180910390fd5b5050565b6101227f48e2b0930000000000000000000000000000000000000000000000000000000060016103ca610b2b565b9190610b59565b60008061016160017f65d27473a5b05206737961f69a3b7a55316862d7a6ef82b3f5455fe92fab43e3610e50565b600181015460609061ffff168067ffffffffffffffff81111561042457610424610e8a565b60405190808252806020026020018201604052801561044d578160200160208202803683370190505b50915060008060005b8361ffff168210156105ab576000818152600287016020526040812054905b806008146105a1578360010193508561ffff1684116105a157600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208a9052604081205460601c90805b88811015610533578a81815181106104e8576104e8610eb9565b602002602001015173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361052b5760019150610533565b6001016104ce565b50801561054257505050610599565b818a898151811061055557610555610eb9565b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508760010197505050505b600101610475565b5050600101610456565b5050825250919050565b600181015460609061ffff168067ffffffffffffffff8111156105da576105da610e8a565b60405190808252806020026020018201604052801561062057816020015b6040805180820190915260008152606060208201528152602001906001900390816105f85790505b50915060008161ffff1667ffffffffffffffff81111561064257610642610e8a565b60405190808252806020026020018201604052801561066b578160200160208202803683370190505b50905060008060005b8461ffff16821015610975576000818152600288016020526040812054905b8060081461096b578360010193508661ffff16841161096b57600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208b9052604081205460601c90805b88811461080d578273ffffffffffffffffffffffffffffffffffffffff168c828151811061071c5761071c610eb9565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff160361080557838c828151811061075657610756610eb9565b6020026020010151602001518b838151811061077457610774610eb9565b60200260200101518151811061078c5761078c610eb9565b60200260200101907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916815250508981815181106107ea576107ea610eb9565b6020026020010180516001019081815250506001915061080d565b6001016106ec565b50801561081c57505050610963565b818b898151811061082f5761082f610eb9565b602090810291909101015173ffffffffffffffffffffffffffffffffffffffff909116905261ffff8a1667ffffffffffffffff81111561087157610871610e8a565b60405190808252806020026020018201604052801561089a578160200160208202803683370190505b508b89815181106108ad576108ad610eb9565b602002602001015160200181905250828b89815181106108cf576108cf610eb9565b6020026020010151602001516000815181106108ed576108ed610eb9565b60200260200101907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191690817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050600189898151811061094d5761094d610eb9565b6020026020010181815250508760010197505050505b600101610693565b5050600101610674565b5060005b828110156109ce57600084828151811061099557610995610eb9565b6020026020010151905060008783815181106109b3576109b3610eb9565b60209081029190910181015101519190915250600101610979565b50508352509092915050565b600182015460609061ffff168067ffffffffffffffff8111156109ff576109ff610e8a565b604051908082528060200260200182016040528015610a28578160200160208202803683370190505b50915060008060005b8361ffff16821015610b20576000818152600288016020526040812054905b80600814610b16578360010193508561ffff168411610b1657600581901b82901b7fffffffff000000000000000000000000000000000000000000000000000000008116600090815260208b9052604090205460601c73ffffffffffffffffffffffffffffffffffffffff8a1603610b0d5780888781518110610ad557610ad5610eb9565b7fffffffff00000000000000000000000000000000000000000000000000000000909216602092830291909101909101526001909501945b50600101610a50565b5050600101610a31565b505082525092915050565b60008061016160017fca9d3e17f264b0f3984e2634e94adb37fa3e6a8103f06aeae6fa59e21c769f5e610e50565b7c01000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831601610bd1576040517f72c683bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7fffffffff00000000000000000000000000000000000000000000000000000000919091166000908152602092909252604090912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b602080825282518282018190526000918401906040840190835b81811015610c8357835173ffffffffffffffffffffffffffffffffffffffff16835260209384019390920191600101610c4f565b509095945050505050565b600081518084526020840193506020830160005b82811015610ce25781517fffffffff0000000000000000000000000000000000000000000000000000000016865260209586019590910190600101610ca2565b5093949350505050565b6000602082016020835280845180835260408501915060408160051b86010192506020860160005b82811015610d90577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0878603018452815173ffffffffffffffffffffffffffffffffffffffff81511686526020810151905060406020870152610d7a6040870182610c8e565b9550506020938401939190910190600101610d14565b50929695505050505050565b600060208284031215610dae57600080fd5b813573ffffffffffffffffffffffffffffffffffffffff81168114610dd257600080fd5b9392505050565b602081526000610dd26020830184610c8e565b600060208284031215610dfe57600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610dd257600080fd5b600060208284031215610e4057600080fd5b81518015158114610dd257600080fd5b81810381811115610161577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea2646970667358221220de651ced90efc2f452f9294ae379f6d6f2e322f3b94dd983b32f0d89ed6385f764736f6c634300081c0033",
  "devdoc": {
    "details": "See https://eips.ethereum.org/EIPS/eip-2535Note: This facet depends on {ProxyAdminFacet} and {InterfaceDetectionFacet}.",
    "errors": {
      "NotProxyAdmin(address)": [
        {
          "params": {
            "account": "The account that was checked."
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "facetAddress(bytes4)": {
        "params": {
          "functionSelector": "The function selector."
        },
        "returns": {
          "facetAddress_": "The facet address that supports `functionSelector`, or the zero address if the facet is not found."
        }
      },
      "facetAddresses()": {
        "returns": {
          "facetAddresses_": "The facet addresses used by the diamond."
        }
      },
      "facetFunctionSelectors(address)": {
        "params": {
          "facetAddress": "The facet address."
        },
        "returns": {
          "facetFunctionSelectors_": "The function selectors supported by `facet`."
        }
      },
      "facets()": {
        "returns": {
          "facets_": "The facet addresses used by the diamond and their function selectors."
        }
      },
      "initDiamondLoupeStorage()": {
        "details": "Reverts with {NotProxyAdmin} if the sender is not the proxy admin."
      }
    },
    "title": "Diamond Loupe (facet version).",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "IllegalInterfaceId()": [
        {
          "notice": "Thrown when setting the illegal interfaceId 0xffffffff."
        }
      ],
      "NotProxyAdmin(address)": [
        {
          "notice": "Thrown when an account is not the proxy admin but is required to."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "facetAddress(bytes4)": {
        "notice": "Gets the facet address that supports a given function selector."
      },
      "facetAddresses()": {
        "notice": "Get all the facet addresses used by the diamond."
      },
      "facetFunctionSelectors(address)": {
        "notice": "Gets all the function selectors supported by a facet."
      },
      "facets()": {
        "notice": "Gets all the facet addresses used by the diamond and their function selectors."
      },
      "initDiamondLoupeStorage()": {
        "notice": "Marks the following ERC165 interface(s) as supported: DiamondLoupe."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}