{
  "address": "0x7D6b2D04673EebaF0a714c95D73566b2325d410A",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IForwarderRegistry",
          "name": "forwarderRegistry",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ERC721BurntToken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ERC721ExistingToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721MintToAddressZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "IllegalInterfaceId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InconsistentArrayLengths",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "NotProxyAdmin",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "NotRoleHolder",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "recipients",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "tokenIds",
          "type": "uint256[]"
        }
      ],
      "name": "deliver",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initERC721DeliverableOnceStorage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x35f084503bc298c35b630d8181e75fe28f80e173594b49a9d23f1debc14bf66e",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xB553C4B21966123d7f8c02Ca6909c110260052E8",
    "contractAddress": null,
    "transactionIndex": 20,
    "gasUsed": "550808",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x41252a790891b9bc3707145dc69d0c1d57cca805fbf5bc821af40f7fbc7455a9",
    "transactionHash": "0x35f084503bc298c35b630d8181e75fe28f80e173594b49a9d23f1debc14bf66e",
    "logs": [],
    "blockNumber": 23260596,
    "cumulativeGasUsed": "7851165",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x316a472D084489CB6d4C66e5eB62aE3AdA17521e"
  ],
  "numDeployments": 1,
  "solcInputHash": "84bab0eb3356c2e3bedca0f2f5a163c5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IForwarderRegistry\",\"name\":\"forwarderRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721BurntToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC721ExistingToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721MintToAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IllegalInterfaceId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InconsistentArrayLengths\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NotProxyAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NotRoleHolder\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initERC721DeliverableOnceStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This contract is to be used as a diamond facet (see ERC2535 Diamond Standard https://eips.ethereum.org/EIPS/eip-2535).Note: This facet depends on {ProxyAdminFacet}, {InterfaceDetectionFacet} and {AccessControlFacet}.\",\"errors\":{\"ERC721BurntToken(uint256)\":[{\"params\":{\"tokenId\":\"The identifier of the token that has been burnt before.\"}}],\"ERC721ExistingToken(uint256)\":[{\"params\":{\"tokenId\":\"The identifier of the token that already exists.\"}}],\"NotProxyAdmin(address)\":[{\"params\":{\"account\":\"The account that was checked.\"}}],\"NotRoleHolder(bytes32,address)\":[{\"params\":{\"account\":\"The account that was checked.\",\"role\":\"The role the caller is missing.\"}}]},\"events\":{\"Transfer(address,address,uint256)\":{\"params\":{\"from\":\"The previous token owner.\",\"to\":\"The new token owner.\",\"tokenId\":\"The transferred token identifier.\"}}},\"kind\":\"dev\",\"methods\":{\"deliver(address[],uint256[])\":{\"details\":\"Reverts with {NotRoleHolder} if the sender does not have the 'minter' role.Reverts with {ERC721BurntToken} if one of `tokenIds` has been previously burnt.\",\"params\":{\"recipients\":\"Addresses of the new tokens owners.\",\"tokenIds\":\"Identifiers of the tokens to mint.\"}},\"initERC721DeliverableOnceStorage()\":{\"details\":\"Reverts with {NotProxyAdmin} if the sender is not the proxy admin.\"}},\"title\":\"ERC721 Non-Fungible Token Standard, optional extension: Deliverable (facet version).\",\"version\":1},\"userdoc\":{\"errors\":{\"ERC721BurntToken(uint256)\":[{\"notice\":\"Thrown when minting a token which has been burnt before (MintableOnce implementation).\"}],\"ERC721ExistingToken(uint256)\":[{\"notice\":\"Thrown when minting a token that already exists.\"}],\"ERC721MintToAddressZero()\":[{\"notice\":\"Thrown when minting a token to the zero address.\"}],\"IllegalInterfaceId()\":[{\"notice\":\"Thrown when setting the illegal interfaceId 0xffffffff.\"}],\"InconsistentArrayLengths()\":[{\"notice\":\"Thrown when the multiple related arrays have different lengths.\"}],\"NotProxyAdmin(address)\":[{\"notice\":\"Thrown when an account is not the proxy admin but is required to.\"}],\"NotRoleHolder(bytes32,address)\":[{\"notice\":\"Thrown when an account does not have the required role.\"}]},\"events\":{\"Transfer(address,address,uint256)\":{\"notice\":\"Emitted when a token is transferred.\"}},\"kind\":\"user\",\"methods\":{\"deliver(address[],uint256[])\":{\"notice\":\"Unsafely mints tokens to multiple recipients.\"},\"initERC721DeliverableOnceStorage()\":{\"notice\":\"Marks the following ERC165 interface(s) as supported: ERC721Deliverable.\"}},\"notice\":\"ERC721Deliverable implementation where burnt tokens cannot be minted again.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/token/ERC721/facets/ERC721DeliverableOnceFacet.sol\":\"ERC721DeliverableOnceFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":99999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"contracts/CommonErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when trying to transfer tokens without calldata to the contract.\\nerror EtherReceptionDisabled();\\n\\n/// @notice Thrown when the multiple related arrays have different lengths.\\nerror InconsistentArrayLengths();\\n\\n/// @notice Thrown when an ETH transfer has failed.\\nerror TransferFailed();\\n\",\"keccak256\":\"0x016ea12044fa81e3c57662985c8cfa863543ca873697926085a0f7cee10622f3\",\"license\":\"MIT\"},\"contracts/access/errors/AccessControlErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when an account does not have the required role.\\n/// @param role The role the caller is missing.\\n/// @param account The account that was checked.\\nerror NotRoleHolder(bytes32 role, address account);\\n\\n/// @notice Thrown when an account does not have the required role on a target contract.\\n/// @param targetContract The contract that was checked.\\n/// @param role The role that was checked.\\n/// @param account The account that was checked.\\nerror NotTargetContractRoleHolder(address targetContract, bytes32 role, address account);\\n\",\"keccak256\":\"0x1e8ef0df72a9832998cd1cdf6a6d902c42c41480425dd0db02c22dc94f22fa15\",\"license\":\"MIT\"},\"contracts/access/errors/Common.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when the target contract is actually not a contract.\\n/// @param targetContract The contract that was checked\\nerror TargetIsNotAContract(address targetContract);\\n\",\"keccak256\":\"0xffd6dcc88e984aeb996af0dedf3e3648e9e09c92efbb707377db195767ff42c5\",\"license\":\"MIT\"},\"contracts/access/events/AccessControlEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when `role` is granted to `account`.\\n/// @param role The role that has been granted.\\n/// @param account The account that has been granted the role.\\n/// @param operator The account that granted the role.\\nevent RoleGranted(bytes32 role, address account, address operator);\\n\\n/// @notice Emitted when `role` is revoked from `account`.\\n/// @param role The role that has been revoked.\\n/// @param account The account that has been revoked the role.\\n/// @param operator The account that revoked the role.\\nevent RoleRevoked(bytes32 role, address account, address operator);\\n\",\"keccak256\":\"0x3362bafa0766fe7254baad2f901e8c36c39004daeb9e58477048d3b7758edcb7\",\"license\":\"MIT\"},\"contracts/access/interfaces/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title Access control via roles management (functions)\\ninterface IAccessControl {\\n    /// @notice Renounces a role by the sender.\\n    /// @dev Reverts if `sender` does not have `role`.\\n    /// @dev Emits a {RoleRevoked} event.\\n    /// @param role The role to renounce.\\n    function renounceRole(bytes32 role) external;\\n\\n    /// @notice Retrieves whether an account has a role.\\n    /// @param role The role.\\n    /// @param account The account.\\n    /// @return hasRole_ Whether `account` has `role`.\\n    function hasRole(bytes32 role, address account) external view returns (bool hasRole_);\\n}\\n\",\"keccak256\":\"0x3a5b8f8d04c1ad412d651ecb26ca76a18ad7cfe154ad4542cf2706ccc98f56e6\",\"license\":\"MIT\"},\"contracts/access/libraries/AccessControlStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {NotRoleHolder, NotTargetContractRoleHolder} from \\\"./../errors/AccessControlErrors.sol\\\";\\nimport {TargetIsNotAContract} from \\\"./../errors/Common.sol\\\";\\nimport {RoleGranted, RoleRevoked} from \\\"./../events/AccessControlEvents.sol\\\";\\nimport {IAccessControl} from \\\"./../interfaces/IAccessControl.sol\\\";\\nimport {Address} from \\\"./../../utils/libraries/Address.sol\\\";\\n\\nlibrary AccessControlStorage {\\n    using Address for address;\\n    using AccessControlStorage for AccessControlStorage.Layout;\\n\\n    struct Layout {\\n        mapping(bytes32 => mapping(address => bool)) roles;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.access.AccessControl.storage\\\")) - 1);\\n\\n    /// @notice Grants a role to an account.\\n    /// @dev Note: Call to this function should be properly access controlled.\\n    /// @dev Emits a {RoleGranted} event if the account did not previously have the role.\\n    /// @param role The role to grant.\\n    /// @param account The account to grant the role to.\\n    /// @param operator The account requesting the role change.\\n    function grantRole(Layout storage s, bytes32 role, address account, address operator) internal {\\n        if (!s.hasRole(role, account)) {\\n            s.roles[role][account] = true;\\n            emit RoleGranted(role, account, operator);\\n        }\\n    }\\n\\n    /// @notice Revokes a role from an account.\\n    /// @dev Note: Call to this function should be properly access controlled.\\n    /// @dev Emits a {RoleRevoked} event if the account previously had the role.\\n    /// @param role The role to revoke.\\n    /// @param account The account to revoke the role from.\\n    /// @param operator The account requesting the role change.\\n    function revokeRole(Layout storage s, bytes32 role, address account, address operator) internal {\\n        if (s.hasRole(role, account)) {\\n            s.roles[role][account] = false;\\n            emit RoleRevoked(role, account, operator);\\n        }\\n    }\\n\\n    /// @notice Renounces a role by the sender.\\n    /// @dev Reverts with {NotRoleHolder} if `sender` does not have `role`.\\n    /// @dev Emits a {RoleRevoked} event.\\n    /// @param sender The message sender.\\n    /// @param role The role to renounce.\\n    function renounceRole(Layout storage s, address sender, bytes32 role) internal {\\n        s.enforceHasRole(role, sender);\\n        s.roles[role][sender] = false;\\n        emit RoleRevoked(role, sender, sender);\\n    }\\n\\n    /// @notice Retrieves whether an account has a role.\\n    /// @param role The role.\\n    /// @param account The account.\\n    /// @return hasRole_ Whether `account` has `role`.\\n    function hasRole(Layout storage s, bytes32 role, address account) internal view returns (bool hasRole_) {\\n        return s.roles[role][account];\\n    }\\n\\n    /// @notice Checks whether an account has a role in a target contract.\\n    /// @param targetContract The contract to check.\\n    /// @param role The role to check.\\n    /// @param account The account to check.\\n    /// @return hasTargetContractRole_ Whether `account` has `role` in `targetContract`.\\n    function hasTargetContractRole(address targetContract, bytes32 role, address account) internal view returns (bool hasTargetContractRole_) {\\n        if (!targetContract.hasBytecode()) revert TargetIsNotAContract(targetContract);\\n        return IAccessControl(targetContract).hasRole(role, account);\\n    }\\n\\n    /// @notice Ensures that an account has a role.\\n    /// @dev Reverts with {NotRoleHolder} if `account` does not have `role`.\\n    /// @param role The role.\\n    /// @param account The account.\\n    function enforceHasRole(Layout storage s, bytes32 role, address account) internal view {\\n        if (!s.hasRole(role, account)) revert NotRoleHolder(role, account);\\n    }\\n\\n    /// @notice Enforces that an account has a role in a target contract.\\n    /// @dev Reverts with {NotTargetContractRoleHolder} if the account does not have the role.\\n    /// @param targetContract The contract to check.\\n    /// @param role The role to check.\\n    /// @param account The account to check.\\n    function enforceHasTargetContractRole(address targetContract, bytes32 role, address account) internal view {\\n        if (!hasTargetContractRole(targetContract, role, account)) revert NotTargetContractRoleHolder(targetContract, role, account);\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x79f9d5ff8238f802faf407106a08bde5665438023b52c51d6d919dfb6df923f1\",\"license\":\"MIT\"},\"contracts/introspection/errors/InterfaceDetectionErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when setting the illegal interfaceId 0xffffffff.\\nerror IllegalInterfaceId();\\n\",\"keccak256\":\"0x0fd7df6f16ddbcaf3f5b8f603a12c0516e1dc5ee08eb770da52691adf070e0bd\",\"license\":\"MIT\"},\"contracts/introspection/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC165 Interface Detection Standard.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-165.\\n/// @dev Note: The ERC-165 identifier for this interface is 0x01ffc9a7.\\ninterface IERC165 {\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId the interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool supported);\\n}\\n\",\"keccak256\":\"0x34f460e915aaaec82d62c228f4813ca758b487034eaa43b65c128389539194d9\",\"license\":\"MIT\"},\"contracts/introspection/libraries/InterfaceDetectionStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IllegalInterfaceId} from \\\"./../errors/InterfaceDetectionErrors.sol\\\";\\nimport {IERC165} from \\\"./../interfaces/IERC165.sol\\\";\\n\\nlibrary InterfaceDetectionStorage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.introspection.InterfaceDetection.storage\\\")) - 1);\\n\\n    bytes4 internal constant ILLEGAL_INTERFACE_ID = 0xffffffff;\\n\\n    /// @notice Sets or unsets an ERC165 interface.\\n    /// @dev Revertswith {IllegalInterfaceId} if `interfaceId` is `0xffffffff`.\\n    /// @param interfaceId the interface identifier.\\n    /// @param supported True to set the interface, false to unset it.\\n    function setSupportedInterface(Layout storage s, bytes4 interfaceId, bool supported) internal {\\n        if (interfaceId == ILLEGAL_INTERFACE_ID) revert IllegalInterfaceId();\\n        s.supportedInterfaces[interfaceId] = supported;\\n    }\\n\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId The interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(Layout storage s, bytes4 interfaceId) internal view returns (bool supported) {\\n        if (interfaceId == ILLEGAL_INTERFACE_ID) {\\n            return false;\\n        }\\n        if (interfaceId == type(IERC165).interfaceId) {\\n            return true;\\n        }\\n        return s.supportedInterfaces[interfaceId];\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeaf559662562be7885b75193ff6994e52cf8109c898ffced02c2b26785d94ee2\",\"license\":\"MIT\"},\"contracts/metatx/base/ForwarderRegistryContextBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IForwarderRegistry} from \\\"./../interfaces/IForwarderRegistry.sol\\\";\\nimport {ERC2771Calldata} from \\\"./../libraries/ERC2771Calldata.sol\\\";\\n\\n/// @title Meta-Transactions Forwarder Registry Context (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Derived from https://github.com/wighawag/universal-forwarder (MIT licence)\\nabstract contract ForwarderRegistryContextBase {\\n    IForwarderRegistry internal immutable _FORWARDER_REGISTRY;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) {\\n        _FORWARDER_REGISTRY = forwarderRegistry;\\n    }\\n\\n    /// @notice Returns the message sender depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgSender() internal view virtual returns (address) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.sender;\\n        }\\n\\n        address sender = ERC2771Calldata.msgSender();\\n\\n        // Return the EIP-2771 calldata-appended sender address if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (msg.sender == address(_FORWARDER_REGISTRY) || _FORWARDER_REGISTRY.isApprovedForwarder(sender, msg.sender, address(this))) {\\n            return sender;\\n        }\\n\\n        return msg.sender;\\n    }\\n\\n    /// @notice Returns the message data depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.data;\\n        }\\n\\n        // Return the EIP-2771 calldata (minus the appended sender) if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (\\n            msg.sender == address(_FORWARDER_REGISTRY) ||\\n            _FORWARDER_REGISTRY.isApprovedForwarder(ERC2771Calldata.msgSender(), msg.sender, address(this))\\n        ) {\\n            return ERC2771Calldata.msgData();\\n        }\\n\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x9a024b7aa6527471d6a097c62dfa94e85a1427ec63776153aff9e5d7ba229040\",\"license\":\"MIT\"},\"contracts/metatx/interfaces/IForwarderRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title Meta-Transactions Forwarder Registry.\\ninterface IForwarderRegistry {\\n    /// @notice Checks whether an account is as an approved meta-transaction forwarder for a sender account to a target contract.\\n    /// @param sender The sender account.\\n    /// @param forwarder The forwarder account.\\n    /// @param target The target contract.\\n    /// @return isApproved True if `forwarder` is an approved meta-transaction forwarder for `sender` to `target`, false otherwise.\\n    function isApprovedForwarder(address sender, address forwarder, address target) external view returns (bool isApproved);\\n}\\n\",\"keccak256\":\"0xdfb17430660876a9214c0cc4c37eb688c565b3c8211151b3413d88d5b4e4c4cb\",\"license\":\"MIT\"},\"contracts/metatx/libraries/ERC2771Calldata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @dev Derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT licence)\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2771\\nlibrary ERC2771Calldata {\\n    /// @notice Returns the sender address appended at the end of the calldata, as specified in EIP-2771.\\n    function msgSender() internal pure returns (address sender) {\\n        assembly {\\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n    /// @notice Returns the calldata while omitting the appended sender address, as specified in EIP-2771.\\n    function msgData() internal pure returns (bytes calldata data) {\\n        unchecked {\\n            return msg.data[:msg.data.length - 20];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8de5057207aa02ba450c95d802f3f77736cafeb1c4e516d6989c27ff5fa1315d\",\"license\":\"MIT\"},\"contracts/proxy/errors/ProxyAdminErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when the initial admin is not set.\\nerror NoInitialProxyAdmin();\\n\\n/// @notice Thrown when an account is not the proxy admin but is required to.\\n/// @param account The account that was checked.\\nerror NotProxyAdmin(address account);\\n\",\"keccak256\":\"0x8ba37d9f154407fc3ddc058b5f678866b274a9674cd850bd8bf73d79e626c160\",\"license\":\"MIT\"},\"contracts/proxy/errors/ProxyInitializationErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when trying to set a phase value that has already been reached.\\n/// @param currentPhase The current phase.\\n/// @param newPhase The new phase trying to be set.\\nerror InitializationPhaseAlreadyReached(uint256 currentPhase, uint256 newPhase);\\n\",\"keccak256\":\"0x85ee7912d0020d0f032e2dacacbec057114235fbdab703753fdcde5c78275543\",\"license\":\"MIT\"},\"contracts/proxy/events/ProxyAdminEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when the proxy admin changes.\\n/// @param previousAdmin the previous admin.\\n/// @param newAdmin the new admin.\\nevent AdminChanged(address previousAdmin, address newAdmin);\\n\",\"keccak256\":\"0x8af172a87e9b4f1188e7837f4aaac8bdb438191b1465cc963f4543da1a435476\",\"license\":\"MIT\"},\"contracts/proxy/libraries/ProxyAdminStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {NoInitialProxyAdmin, NotProxyAdmin} from \\\"./../errors/ProxyAdminErrors.sol\\\";\\nimport {AdminChanged} from \\\"./../events/ProxyAdminEvents.sol\\\";\\nimport {ProxyInitialization} from \\\"./ProxyInitialization.sol\\\";\\n\\nlibrary ProxyAdminStorage {\\n    using ProxyAdminStorage for ProxyAdminStorage.Layout;\\n\\n    struct Layout {\\n        address admin;\\n    }\\n\\n    // bytes32 public constant PROXYADMIN_STORAGE_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n    bytes32 internal constant PROXY_INIT_PHASE_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin.phase\\\")) - 1);\\n\\n    /// @notice Initializes the storage with an initial admin (immutable version).\\n    /// @dev Note: This function should be called ONLY in the constructor of an immutable (non-proxied) contract.\\n    /// @dev Reverts {NoInitialProxyAdmin} if `initialAdmin` is the zero address.\\n    /// @dev Emits an {AdminChanged} event.\\n    /// @param initialAdmin The initial payout wallet.\\n    function constructorInit(Layout storage s, address initialAdmin) internal {\\n        if (initialAdmin == address(0)) revert NoInitialProxyAdmin();\\n        s.admin = initialAdmin;\\n        emit AdminChanged(address(0), initialAdmin);\\n    }\\n\\n    /// @notice Initializes the storage with an initial admin (proxied version).\\n    /// @notice Sets the proxy initialization phase to `1`.\\n    /// @dev Note: This function should be called ONLY in the init function of a proxied contract.\\n    /// @dev Reverts with {InitializationPhaseAlreadyReached} if the proxy initialization phase is set to `1` or above.\\n    /// @dev Reverts {NoInitialProxyAdmin} if `initialAdmin` is the zero address.\\n    /// @dev Emits an {AdminChanged} event.\\n    /// @param initialAdmin The initial payout wallet.\\n    function proxyInit(Layout storage s, address initialAdmin) internal {\\n        ProxyInitialization.setPhase(PROXY_INIT_PHASE_SLOT, 1);\\n        s.constructorInit(initialAdmin);\\n    }\\n\\n    /// @notice Sets a new proxy admin.\\n    /// @dev Reverts with {NotProxyAdmin} if `sender` is not the proxy admin.\\n    /// @dev Emits an {AdminChanged} event if `newAdmin` is different from the current proxy admin.\\n    /// @param newAdmin The new proxy admin.\\n    function changeProxyAdmin(Layout storage s, address sender, address newAdmin) internal {\\n        address previousAdmin = s.admin;\\n        if (sender != previousAdmin) revert NotProxyAdmin(sender);\\n        if (previousAdmin != newAdmin) {\\n            s.admin = newAdmin;\\n            emit AdminChanged(previousAdmin, newAdmin);\\n        }\\n    }\\n\\n    /// @notice Gets the proxy admin.\\n    /// @return admin The proxy admin\\n    function proxyAdmin(Layout storage s) internal view returns (address admin) {\\n        return s.admin;\\n    }\\n\\n    /// @notice Ensures that an account is the proxy admin.\\n    /// @dev Reverts with {NotProxyAdmin} if `account` is not the proxy admin.\\n    /// @param account The account.\\n    function enforceIsProxyAdmin(Layout storage s, address account) internal view {\\n        if (account != s.admin) revert NotProxyAdmin(account);\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1f1cb9a6470f14aa9942dedd288aaffc6c582abf831edeb52e51a3691cdd32a4\",\"license\":\"MIT\"},\"contracts/proxy/libraries/ProxyInitialization.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {InitializationPhaseAlreadyReached} from \\\"./../errors/ProxyInitializationErrors.sol\\\";\\nimport {StorageSlot} from \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n/// @notice Multiple calls protection for storage-modifying proxy initialization functions.\\nlibrary ProxyInitialization {\\n    /// @notice Sets the initialization phase during a storage-modifying proxy initialization function.\\n    /// @dev Reverts with {InitializationPhaseAlreadyReached} if `phase` has been reached already.\\n    /// @param storageSlot the storage slot where `phase` is stored.\\n    /// @param phase the initialization phase.\\n    function setPhase(bytes32 storageSlot, uint256 phase) internal {\\n        StorageSlot.Uint256Slot storage currentVersion = StorageSlot.getUint256Slot(storageSlot);\\n        uint256 currentPhase = currentVersion.value;\\n        if (currentPhase >= phase) revert InitializationPhaseAlreadyReached(currentPhase, phase);\\n        currentVersion.value = phase;\\n    }\\n}\\n\",\"keccak256\":\"0xdc2cca29702fe573cb5af8c3320eafe7a490aef99bcaafe1e6575159bb0007d7\",\"license\":\"MIT\"},\"contracts/token/ERC721/base/ERC721DeliverableOnceBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {IERC721Deliverable} from \\\"./../interfaces/IERC721Deliverable.sol\\\";\\nimport {ERC721Storage} from \\\"./../libraries/ERC721Storage.sol\\\";\\nimport {AccessControlStorage} from \\\"./../../../access/libraries/AccessControlStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Deliverable (proxiable version)\\n/// @notice ERC721Deliverable implementation where burnt tokens cannot be minted again.\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC721 (Non-Fungible Token Standard).\\n/// @dev Note: This contract requires AccessControl.\\nabstract contract ERC721DeliverableOnceBase is IERC721Deliverable, Context {\\n    using ERC721Storage for ERC721Storage.Layout;\\n    using AccessControlStorage for AccessControlStorage.Layout;\\n\\n    // prevent variable name clash with public ERC721MintableOnceBase.MINTER_ROLE\\n    bytes32 private constant _MINTER_ROLE = \\\"minter\\\";\\n\\n    /// @inheritdoc IERC721Deliverable\\n    /// @dev Reverts with {NotRoleHolder} if the sender does not have the 'minter' role.\\n    /// @dev Reverts with {ERC721BurntToken} if one of `tokenIds` has been previously burnt.\\n    function deliver(address[] calldata recipients, uint256[] calldata tokenIds) external virtual {\\n        AccessControlStorage.layout().enforceHasRole(_MINTER_ROLE, _msgSender());\\n        ERC721Storage.layout().deliverOnce(recipients, tokenIds);\\n    }\\n}\\n\",\"keccak256\":\"0xff33958a1d23f033a4a1198d3af9fc4bb69b035398da4a732f7f3f18e9290ea9\",\"license\":\"MIT\"},\"contracts/token/ERC721/errors/ERC721Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when trying to approve oneself.\\n/// @param account The account trying to approve itself.\\nerror ERC721SelfApproval(address account);\\n\\n/// @notice Thrown when trying to approveForAll oneself.\\n/// @param account The account trying to approveForAll itself.\\nerror ERC721SelfApprovalForAll(address account);\\n\\n/// @notice Thrown when a sender tries to set a token approval but is neither the owner nor approvedForAll by the owner.\\n/// @param sender The message sender.\\n/// @param tokenId The identifier of the token.\\nerror ERC721NonApprovedForApproval(address sender, address owner, uint256 tokenId);\\n\\n/// @notice Thrown when transferring a token to the zero address.\\nerror ERC721TransferToAddressZero();\\n\\n/// @notice Thrown when a token does not exist but is required to.\\n/// @param tokenId The identifier of the token that was checked.\\nerror ERC721NonExistingToken(uint256 tokenId);\\n\\n/// @notice Thrown when a sender tries to transfer a token but is neither the owner nor approved by the owner.\\n/// @param sender The message sender.\\n/// @param tokenId The identifier of the token.\\nerror ERC721NonApprovedForTransfer(address sender, address owner, uint256 tokenId);\\n\\n/// @notice Thrown when a token is not owned by the expected account.\\n/// @param account The account that was expected to own the token.\\n/// @param tokenId The identifier of the token.\\nerror ERC721NonOwnedToken(address account, uint256 tokenId);\\n\\n/// @notice Thrown when a safe transfer is rejected by the recipient contract.\\n/// @param recipient The recipient contract.\\n/// @param tokenId The identifier of the token.\\nerror ERC721SafeTransferRejected(address recipient, uint256 tokenId);\\n\\n/// @notice Thrown when querying the balance of the zero address.\\nerror ERC721BalanceOfAddressZero();\\n\",\"keccak256\":\"0x8750bbb24c63b87c60d48d460804a3147f42cb4cb8ae4aeae73dbacb939ee992\",\"license\":\"MIT\"},\"contracts/token/ERC721/errors/ERC721MintableErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when minting a token to the zero address.\\nerror ERC721MintToAddressZero();\\n\\n/// @notice Thrown when minting a token that already exists.\\n/// @param tokenId The identifier of the token that already exists.\\nerror ERC721ExistingToken(uint256 tokenId);\\n\",\"keccak256\":\"0x6202bfb04dea32deb133a87d5df0cd74dc121d4195dbfaaf214595a714723f4e\",\"license\":\"MIT\"},\"contracts/token/ERC721/errors/ERC721MintableOnceErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Thrown when minting a token which has been burnt before (MintableOnce implementation).\\n/// @param tokenId The identifier of the token that has been burnt before.\\nerror ERC721BurntToken(uint256 tokenId);\\n\",\"keccak256\":\"0xfca46176cc52e35a870ee0ed24eb9424046b68b22992eea0d4c3223aaf6ba8db\",\"license\":\"MIT\"},\"contracts/token/ERC721/events/ERC721Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @notice Emitted when a token is transferred.\\n/// @param from The previous token owner.\\n/// @param to The new token owner.\\n/// @param tokenId The transferred token identifier.\\nevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n/// @notice Emitted when a single token approval is set.\\n/// @param owner The token owner.\\n/// @param approved The approved address.\\n/// @param tokenId The approved token identifier.\\nevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n/// @notice Emitted when an approval for all tokens is set or unset.\\n/// @param owner The tokens owner.\\n/// @param operator The approved address.\\n/// @param approved True when then approval is set, false when it is unset.\\nevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\",\"keccak256\":\"0xa41f225efca959c49a61d53cda1ddefa834530050beed152c721e78f56de48be\",\"license\":\"MIT\"},\"contracts/token/ERC721/facets/ERC721DeliverableOnceFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.28;\\n\\nimport {IForwarderRegistry} from \\\"./../../../metatx/interfaces/IForwarderRegistry.sol\\\";\\nimport {ERC721Storage} from \\\"./../libraries/ERC721Storage.sol\\\";\\nimport {ProxyAdminStorage} from \\\"./../../../proxy/libraries/ProxyAdminStorage.sol\\\";\\nimport {ERC721DeliverableOnceBase} from \\\"./../base/ERC721DeliverableOnceBase.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {ForwarderRegistryContextBase} from \\\"./../../../metatx/base/ForwarderRegistryContextBase.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Deliverable (facet version).\\n/// @notice ERC721Deliverable implementation where burnt tokens cannot be minted again.\\n/// @dev This contract is to be used as a diamond facet (see ERC2535 Diamond Standard https://eips.ethereum.org/EIPS/eip-2535).\\n/// @dev Note: This facet depends on {ProxyAdminFacet}, {InterfaceDetectionFacet} and {AccessControlFacet}.\\ncontract ERC721DeliverableOnceFacet is ERC721DeliverableOnceBase, ForwarderRegistryContextBase {\\n    using ProxyAdminStorage for ProxyAdminStorage.Layout;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) ForwarderRegistryContextBase(forwarderRegistry) {}\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Deliverable.\\n    /// @dev Reverts with {NotProxyAdmin} if the sender is not the proxy admin.\\n    function initERC721DeliverableOnceStorage() external {\\n        ProxyAdminStorage.layout().enforceIsProxyAdmin(_msgSender());\\n        ERC721Storage.initERC721Deliverable();\\n    }\\n\\n    /// @inheritdoc ForwarderRegistryContextBase\\n    function _msgSender() internal view virtual override(Context, ForwarderRegistryContextBase) returns (address) {\\n        return ForwarderRegistryContextBase._msgSender();\\n    }\\n\\n    /// @inheritdoc ForwarderRegistryContextBase\\n    function _msgData() internal view virtual override(Context, ForwarderRegistryContextBase) returns (bytes calldata) {\\n        return ForwarderRegistryContextBase._msgData();\\n    }\\n}\\n\",\"keccak256\":\"0x9ecfccd5628340776a1b4c8d182856f1a45c1f47aa879f5b85d4e6d161c1b9af\",\"license\":\"MIT\"},\"contracts/token/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC721 Non-Fungible Token Standard, basic interface (functions).\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev This interface only contains the standard functions. See IERC721Events for the events.\\n/// @dev Note: The ERC-165 identifier for this interface is 0x80ac58cd.\\ninterface IERC721 {\\n    /// @notice Sets or unsets an approval to transfer a single token on behalf of its owner.\\n    /// @dev Note: There can only be one approved address per token at a given time.\\n    /// @dev Note: A token approval gets reset when this token is transferred, including a self-transfer.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @dev Reverts if `to` is the token owner.\\n    /// @dev Reverts if the sender is not the token owner and has not been approved by the token owner.\\n    /// @dev Emits an {Approval} event.\\n    /// @param to The address to approve, or the zero address to remove any existing approval.\\n    /// @param tokenId The token identifier to give approval for.\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /// @notice Sets or unsets an approval to transfer all tokens on behalf of their owner.\\n    /// @dev Reverts if the sender is the same as `operator`.\\n    /// @dev Emits an {ApprovalForAll} event.\\n    /// @param operator The address to approve for all tokens.\\n    /// @param approved True to set an approval for all tokens, false to unset it.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Unsafely transfers the ownership of a token to a recipient.\\n    /// @dev Note: Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer. Self-transfers are possible.\\n    /// @param tokenId The identifier of the token to transfer.\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @notice Safely transfers the ownership of a token to a recipient.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @notice Safely transfers the ownership of a token to a recipient.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    /// @param data Optional data to send along to a receiver contract.\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /// @notice Gets the balance of an address.\\n    /// @dev Reverts if `owner` is the zero address.\\n    /// @param owner The address to query the balance of.\\n    /// @return balance The amount owned by the owner.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Gets the owner of a token.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @param tokenId The token identifier to query the owner of.\\n    /// @return tokenOwner The owner of the token identifier.\\n    function ownerOf(uint256 tokenId) external view returns (address tokenOwner);\\n\\n    /// @notice Gets the approved address for a token.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @param tokenId The token identifier to query the approval of.\\n    /// @return approved The approved address for the token identifier, or the zero address if no approval is set.\\n    function getApproved(uint256 tokenId) external view returns (address approved);\\n\\n    /// @notice Gets whether an operator is approved for all tokens by an owner.\\n    /// @param owner The address which gives the approval for all tokens.\\n    /// @param operator The address which receives the approval for all tokens.\\n    /// @return approvedForAll Whether the operator is approved for all tokens by the owner.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool approvedForAll);\\n}\\n\",\"keccak256\":\"0x0ae492d8a517113ac1931fe3be5432d7eafd5cb66f6ade9491531ebea1b5e67f\",\"license\":\"MIT\"},\"contracts/token/ERC721/interfaces/IERC721BatchTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Batch Transfer.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0xf3993d11.\\ninterface IERC721BatchTransfer {\\n    /// @notice Unsafely transfers a batch of tokens to a recipient.\\n    /// @dev Resets the token approval for each of `tokenIds`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` is not owned by `from`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for each of `tokenIds`.\\n    /// @dev Emits an {IERC721-Transfer} event for each of `tokenIds`.\\n    /// @param from Current tokens owner.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenIds Identifiers of the tokens to transfer.\\n    function batchTransferFrom(address from, address to, uint256[] calldata tokenIds) external;\\n}\\n\",\"keccak256\":\"0x9e88caecf03d56198da4e1d2e684ad5263aab7548c5a30a68acff79f359f2d91\",\"license\":\"MIT\"},\"contracts/token/ERC721/interfaces/IERC721Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Burnable.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x8b8b4ef5.\\ninterface IERC721Burnable {\\n    /// @notice Burns a token.\\n    /// @dev Reverts if `tokenId` is not owned by `from`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Emits an {IERC721-Transfer} event with `to` set to the zero address.\\n    /// @param from The current token owner.\\n    /// @param tokenId The identifier of the token to burn.\\n    function burnFrom(address from, uint256 tokenId) external;\\n\\n    /// @notice Burns a batch of tokens.\\n    /// @dev Reverts if one of `tokenIds` is not owned by `from`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for each of `tokenIds`.\\n    /// @dev Emits an {IERC721-Transfer} event with `to` set to the zero address for each of `tokenIds`.\\n    /// @param from The current tokens owner.\\n    /// @param tokenIds The identifiers of the tokens to burn.\\n    function batchBurnFrom(address from, uint256[] calldata tokenIds) external;\\n}\\n\",\"keccak256\":\"0x5d1eb60e1aa12fa9149bf3b1786513928399255667791165c90456fc2d6876a0\",\"license\":\"MIT\"},\"contracts/token/ERC721/interfaces/IERC721Deliverable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Deliverable.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x9da5e832.\\ninterface IERC721Deliverable {\\n    /// @notice Unsafely mints tokens to multiple recipients.\\n    /// @dev Reverts if `recipients` and `tokenIds` have different lengths.\\n    /// @dev Reverts if one of `recipients` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` already exists.\\n    /// @dev Emits an {IERC721-Transfer} event from the zero address for each of `recipients` and `tokenIds`.\\n    /// @param recipients Addresses of the new tokens owners.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function deliver(address[] calldata recipients, uint256[] calldata tokenIds) external;\\n}\\n\",\"keccak256\":\"0xfdf3696a08b524bec17ed6813694bd80be44f1250c8bdc9fc961f8c9ba7b4e08\",\"license\":\"MIT\"},\"contracts/token/ERC721/interfaces/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Metadata.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x5b5e139f.\\ninterface IERC721Metadata {\\n    /// @notice Gets the name of the token. E.g. \\\"My Token\\\".\\n    /// @return tokenName The name of the token.\\n    function name() external view returns (string memory tokenName);\\n\\n    /// @notice Gets the symbol of the token. E.g. \\\"TOK\\\".\\n    /// @return tokenSymbol The symbol of the token.\\n    function symbol() external view returns (string memory tokenSymbol);\\n\\n    /// @notice Gets the metadata URI for a token identifier.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @param tokenId The token identifier.\\n    /// @return uri The metadata URI for the token identifier.\\n    function tokenURI(uint256 tokenId) external view returns (string memory uri);\\n}\\n\",\"keccak256\":\"0x1460ac650981f3dee2c9750fb77876c861bb8afc0f09190be6fe2a5f39de0328\",\"license\":\"MIT\"},\"contracts/token/ERC721/interfaces/IERC721Mintable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Mintable.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x8e773e13.\\ninterface IERC721Mintable {\\n    /// @notice Unsafely mints a token.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `tokenId` already exists.\\n    /// @dev Emits an {IERC721-Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    function mint(address to, uint256 tokenId) external;\\n\\n    /// @notice Safely mints a token.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `tokenId` already exists.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits an {IERC721-Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    /// @param data Optional data to pass along to the receiver call.\\n    function safeMint(address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /// @notice Unsafely mints a batch of tokens.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` already exists.\\n    /// @dev Emits an {IERC721-Transfer} event from the zero address for each of `tokenIds`.\\n    /// @param to Address of the new tokens owner.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function batchMint(address to, uint256[] calldata tokenIds) external;\\n}\\n\",\"keccak256\":\"0xc06f8cf14e7f365df82b2ac493e856a88993d43c59ca83c995a990d5be6bf2d7\",\"license\":\"MIT\"},\"contracts/token/ERC721/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n/// @title ERC721 Non-Fungible Token Standard, Tokens Receiver.\\n/// @notice Interface for supporting safe transfers from ERC721 contracts.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x150b7a02.\\ninterface IERC721Receiver {\\n    /// @notice Handles the receipt of an ERC721 token.\\n    /// @dev Note: This function is called by an ERC721 contract after a safe transfer.\\n    /// @dev Note: The ERC721 contract address is always the message sender.\\n    /// @param operator The initiator of the safe transfer.\\n    /// @param from The previous token owner.\\n    /// @param tokenId The token identifier.\\n    /// @param data Optional additional data with no specified format.\\n    /// @return magicValue `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))` (`0x150b7a02`) to accept, any other value to refuse.\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0xf66d2fe143e0e46475c63ab2bcbd8a0208ace23d1d151d00b7fa101c178759b7\",\"license\":\"MIT\"},\"contracts/token/ERC721/libraries/ERC721Storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n// solhint-disable-next-line max-line-length\\nimport {ERC721SelfApproval, ERC721SelfApprovalForAll, ERC721NonApprovedForApproval, ERC721TransferToAddressZero, ERC721NonExistingToken, ERC721NonApprovedForTransfer, ERC721NonOwnedToken, ERC721SafeTransferRejected, ERC721BalanceOfAddressZero} from \\\"./../errors/ERC721Errors.sol\\\";\\nimport {ERC721MintToAddressZero, ERC721ExistingToken} from \\\"./../errors/ERC721MintableErrors.sol\\\";\\nimport {ERC721BurntToken} from \\\"./../errors/ERC721MintableOnceErrors.sol\\\";\\nimport {InconsistentArrayLengths} from \\\"./../../../CommonErrors.sol\\\";\\nimport {Transfer, Approval, ApprovalForAll} from \\\"./../events/ERC721Events.sol\\\";\\nimport {IERC721} from \\\"./../interfaces/IERC721.sol\\\";\\nimport {IERC721BatchTransfer} from \\\"./../interfaces/IERC721BatchTransfer.sol\\\";\\nimport {IERC721Metadata} from \\\"./../interfaces/IERC721Metadata.sol\\\";\\nimport {IERC721Mintable} from \\\"./../interfaces/IERC721Mintable.sol\\\";\\nimport {IERC721Deliverable} from \\\"./../interfaces/IERC721Deliverable.sol\\\";\\nimport {IERC721Burnable} from \\\"./../interfaces/IERC721Burnable.sol\\\";\\nimport {IERC721Receiver} from \\\"./../interfaces/IERC721Receiver.sol\\\";\\nimport {Address} from \\\"./../../../utils/libraries/Address.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./../../../introspection/libraries/InterfaceDetectionStorage.sol\\\";\\n\\nlibrary ERC721Storage {\\n    using Address for address;\\n    using ERC721Storage for ERC721Storage.Layout;\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n\\n    struct Layout {\\n        mapping(uint256 => uint256) owners;\\n        mapping(address => uint256) balances;\\n        mapping(uint256 => address) approvals;\\n        mapping(address => mapping(address => bool)) operators;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.token.ERC721.ERC721.storage\\\")) - 1);\\n\\n    bytes4 internal constant ERC721_RECEIVED = IERC721Receiver.onERC721Received.selector;\\n\\n    // Single token approval flag\\n    // This bit is set in the owner's value to indicate that there is an approval set for this token\\n    uint256 internal constant TOKEN_APPROVAL_OWNER_FLAG = 1 << 160;\\n\\n    // Burnt token magic value\\n    // This magic number is used as the owner's value to indicate that the token has been burnt\\n    uint256 internal constant BURNT_TOKEN_OWNER_VALUE = 0xdead000000000000000000000000000000000000000000000000000000000000;\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721.\\n    function init() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721BatchTransfer.\\n    function initERC721BatchTransfer() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721BatchTransfer).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Metadata.\\n    function initERC721Metadata() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Metadata).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Mintable.\\n    function initERC721Mintable() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Mintable).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Deliverable.\\n    function initERC721Deliverable() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Deliverable).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Burnable.\\n    function initERC721Burnable() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Burnable).interfaceId, true);\\n    }\\n\\n    /// @notice Sets or unsets an approval to transfer a single token on behalf of its owner.\\n    /// @dev Note: This function implements {ERC721-approve(address,uint256)}.\\n    /// @dev Reverts with {ERC721NonExistingToken} if `tokenId` does not exist.\\n    /// @dev Reverts with {ERC721SelfApproval} if `to` is the token owner.\\n    /// @dev Reverts with {ERC721NonApprovedForApproval} if `sender` is not the token owner and has not been approved by the token owner.\\n    /// @dev Emits an {Approval} event.\\n    /// @param sender The message sender.\\n    /// @param to The address to approve, or the zero address to remove any existing approval.\\n    /// @param tokenId The token identifier to give approval for.\\n    function approve(Layout storage s, address sender, address to, uint256 tokenId) internal {\\n        uint256 owner = s.owners[tokenId];\\n        if (!_tokenExists(owner)) revert ERC721NonExistingToken(tokenId);\\n        address ownerAddress = _tokenOwner(owner);\\n        if (to == ownerAddress) revert ERC721SelfApproval(ownerAddress);\\n        if (!_isOperatable(s, ownerAddress, sender)) revert ERC721NonApprovedForApproval(sender, ownerAddress, tokenId);\\n        if (to == address(0)) {\\n            if (_tokenHasApproval(owner)) {\\n                // remove the approval bit if it is present\\n                s.owners[tokenId] = uint256(uint160(ownerAddress));\\n            }\\n        } else {\\n            uint256 ownerWithApprovalBit = owner | TOKEN_APPROVAL_OWNER_FLAG;\\n            if (owner != ownerWithApprovalBit) {\\n                // add the approval bit if it is not present\\n                s.owners[tokenId] = ownerWithApprovalBit;\\n            }\\n            s.approvals[tokenId] = to;\\n        }\\n        emit Approval(ownerAddress, to, tokenId);\\n    }\\n\\n    /// @notice Sets or unsets an approval to transfer all tokens on behalf of their owner.\\n    /// @dev Note: This function implements {ERC721-setApprovalForAll(address,bool)}.\\n    /// @dev Reverts with {ERC721SelfApprovalForAll} if `sender` is the same as `operator`.\\n    /// @dev Emits an {ApprovalForAll} event.\\n    /// @param sender The message sender.\\n    /// @param operator The address to approve for all tokens.\\n    /// @param approved True to set an approval for all tokens, false to unset it.\\n    function setApprovalForAll(Layout storage s, address sender, address operator, bool approved) internal {\\n        if (operator == sender) revert ERC721SelfApprovalForAll(sender);\\n        s.operators[sender][operator] = approved;\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /// @notice Unsafely transfers the ownership of a token to a recipient by a sender.\\n    /// @dev Note: This function implements {ERC721-transferFrom(address,address,uint256)}.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts with {ERC721TransferToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721NonExistingToken} if `tokenId` does not exist.\\n    /// @dev Reverts with {ERC721NonOwnedToken} if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts with {ERC721NonApprovedForTransfer} if `sender` is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param sender The message sender.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    function transferFrom(Layout storage s, address sender, address from, address to, uint256 tokenId) internal {\\n        if (to == address(0)) revert ERC721TransferToAddressZero();\\n\\n        uint256 owner = s.owners[tokenId];\\n        if (!_tokenExists(owner)) revert ERC721NonExistingToken(tokenId);\\n        if (_tokenOwner(owner) != from) revert ERC721NonOwnedToken(from, tokenId);\\n\\n        if (!_isOperatable(s, from, sender)) {\\n            if (!_tokenHasApproval(owner) || sender != s.approvals[tokenId]) revert ERC721NonApprovedForTransfer(sender, from, tokenId);\\n        }\\n\\n        s.owners[tokenId] = uint256(uint160(to));\\n        if (from != to) {\\n            unchecked {\\n                // cannot underflow as balance is verified through ownership\\n                --s.balances[from];\\n                //  cannot overflow as supply cannot overflow\\n                ++s.balances[to];\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /// @notice Safely transfers the ownership of a token to a recipient by a sender.\\n    /// @dev Note: This function implements {ERC721-safeTransferFrom(address,address,uint256)}.\\n    /// @dev Warning: Since a `to` contract can run arbitrary code, developers should be aware of potential re-entrancy attacks.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts with {ERC721TransferToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721NonExistingToken} if `tokenId` does not exist.\\n    /// @dev Reverts with {ERC721NonOwnedToken} if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts with {ERC721NonApprovedForTransfer} if `sender` is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Reverts with {ERC721SafeTransferRejected} if `to` is a contract and the call to\\n    ///  {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param sender The message sender.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    function safeTransferFrom(Layout storage s, address sender, address from, address to, uint256 tokenId) internal {\\n        s.transferFrom(sender, from, to, tokenId);\\n        if (to.hasBytecode()) {\\n            _callOnERC721Received(sender, from, to, tokenId, \\\"\\\");\\n        }\\n    }\\n\\n    /// @notice Safely transfers the ownership of a token to a recipient by a sender.\\n    /// @dev Note: This function implements {ERC721-safeTransferFrom(address,address,uint256,bytes)}.\\n    /// @dev Warning: Since a `to` contract can run arbitrary code, developers should be aware of potential re-entrancy attacks.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts with {ERC721TransferToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721NonExistingToken} if `tokenId` does not exist.\\n    /// @dev Reverts with {ERC721NonOwnedToken} if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts with {ERC721NonApprovedForTransfer} if `sender` is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Reverts with {ERC721SafeTransferRejected} if `to` is a contract and the call to\\n    ///  {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param sender The message sender.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    /// @param data Optional data to send along to a receiver contract.\\n    function safeTransferFrom(Layout storage s, address sender, address from, address to, uint256 tokenId, bytes calldata data) internal {\\n        s.transferFrom(sender, from, to, tokenId);\\n        if (to.hasBytecode()) {\\n            _callOnERC721Received(sender, from, to, tokenId, data);\\n        }\\n    }\\n\\n    /// @notice Unsafely transfers a batch of tokens to a recipient by a sender.\\n    /// @dev Note: This function implements {ERC721BatchTransfer-batchTransferFrom(address,address,uint256[])}.\\n    /// @dev Resets the token approval for each of `tokenIds`.\\n    /// @dev Reverts with {ERC721TransferToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721NonExistingToken} if one of `tokenIds` does not exist.\\n    /// @dev Reverts with {ERC721NonOwnedToken} if one of `tokenIds` is not owned by `from`.\\n    /// @dev Reverts with {ERC721NonApprovedForTransfer} if the sender is not `from` and has not been approved by `from` for each of `tokenIds`.\\n    /// @dev Emits a {Transfer} event for each of `tokenIds`.\\n    /// @param sender The message sender.\\n    /// @param from Current tokens owner.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenIds Identifiers of the tokens to transfer.\\n    function batchTransferFrom(Layout storage s, address sender, address from, address to, uint256[] calldata tokenIds) internal {\\n        if (to == address(0)) revert ERC721TransferToAddressZero();\\n        bool operatable = _isOperatable(s, from, sender);\\n\\n        uint256 length = tokenIds.length;\\n        for (uint256 i; i < length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n            uint256 owner = s.owners[tokenId];\\n            if (!_tokenExists(owner)) revert ERC721NonExistingToken(tokenId);\\n            if (_tokenOwner(owner) != from) revert ERC721NonOwnedToken(from, tokenId);\\n            if (!operatable) {\\n                if (!_tokenHasApproval(owner) || sender != s.approvals[tokenId]) revert ERC721NonApprovedForTransfer(sender, from, tokenId);\\n            }\\n            s.owners[tokenId] = uint256(uint160(to));\\n            emit Transfer(from, to, tokenId);\\n        }\\n\\n        if (from != to && length != 0) {\\n            unchecked {\\n                // cannot underflow as balance is verified through ownership\\n                s.balances[from] -= length;\\n                // cannot overflow as supply cannot overflow\\n                s.balances[to] += length;\\n            }\\n        }\\n    }\\n\\n    /// @notice Unsafely mints a token.\\n    /// @dev Note: This function implements {ERC721Mintable-mint(address,uint256)}.\\n    /// @dev Note: Either `mint` or `mintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts with {ERC721MintToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721ExistingToken} if `tokenId` already exists.\\n    /// @dev Emits a {Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    function mint(Layout storage s, address to, uint256 tokenId) internal {\\n        if (to == address(0)) revert ERC721MintToAddressZero();\\n        if (_tokenExists(s.owners[tokenId])) revert ERC721ExistingToken(tokenId);\\n\\n        s.owners[tokenId] = uint256(uint160(to));\\n\\n        unchecked {\\n            // cannot overflow due to the cost of minting individual tokens\\n            ++s.balances[to];\\n        }\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /// @notice Safely mints a token.\\n    /// @dev Note: This function implements {ERC721Mintable-safeMint(address,uint256,bytes)}.\\n    /// @dev Note: Either `safeMint` or `safeMintOnce` should be used in a given contract, but not both.\\n    /// @dev Warning: Since a `to` contract can run arbitrary code, developers should be aware of potential re-entrancy attacks.\\n    /// @dev Reverts with {ERC721MintToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721ExistingToken} if `tokenId` already exists.\\n    /// @dev Reverts with {ERC721SafeTransferRejected} if `to` is a contract and the call to\\n    ///  {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    /// @param data Optional data to pass along to the receiver call.\\n    function safeMint(Layout storage s, address sender, address to, uint256 tokenId, bytes memory data) internal {\\n        s.mint(to, tokenId);\\n        if (to.hasBytecode()) {\\n            _callOnERC721Received(sender, address(0), to, tokenId, data);\\n        }\\n    }\\n\\n    /// @notice Unsafely mints a batch of tokens.\\n    /// @dev Note: This function implements {ERC721Mintable-batchMint(address,uint256[])}.\\n    /// @dev Note: Either `batchMint` or `batchMintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts with {ERC721MintToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721ExistingToken} if one of `tokenIds` already exists.\\n    /// @dev Emits a {Transfer} event from the zero address for each of `tokenIds`.\\n    /// @param to Address of the new tokens owner.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function batchMint(Layout storage s, address to, uint256[] memory tokenIds) internal {\\n        if (to == address(0)) revert ERC721MintToAddressZero();\\n\\n        uint256 length = tokenIds.length;\\n        for (uint256 i; i < length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n            if (_tokenExists(s.owners[tokenId])) revert ERC721ExistingToken(tokenId);\\n\\n            s.owners[tokenId] = uint256(uint160(to));\\n            emit Transfer(address(0), to, tokenId);\\n        }\\n\\n        unchecked {\\n            s.balances[to] += length;\\n        }\\n    }\\n\\n    /// @notice Unsafely mints tokens to multiple recipients.\\n    /// @dev Note: This function implements {ERC721Deliverable-deliver(address[],uint256[])}.\\n    /// @dev Note: Either `deliver` or `deliverOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts with {InconsistentArrayLengths} if `recipients` and `tokenIds` have different lengths.\\n    /// @dev Reverts with {ERC721MintToAddressZero} if one of `recipients` is the zero address.\\n    /// @dev Reverts with {ERC721ExistingToken} if one of `tokenIds` already exists.\\n    /// @dev Emits a {Transfer} event from the zero address for each of `recipients` and `tokenIds`.\\n    /// @param recipients Addresses of the new tokens owners.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function deliver(Layout storage s, address[] memory recipients, uint256[] memory tokenIds) internal {\\n        uint256 length = recipients.length;\\n        if (length != tokenIds.length) revert InconsistentArrayLengths();\\n        for (uint256 i; i < length; ++i) {\\n            s.mint(recipients[i], tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Unsafely mints a token once.\\n    /// @dev Note: This function implements {ERC721Mintable-mint(address,uint256)}.\\n    /// @dev Note: Either `mint` or `mintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts with {ERC721MintToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721ExistingToken} if `tokenId` already exists.\\n    /// @dev Reverts with {ERC721BurntToken} if `tokenId` has been previously burnt.\\n    /// @dev Emits a {Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    function mintOnce(Layout storage s, address to, uint256 tokenId) internal {\\n        if (to == address(0)) revert ERC721MintToAddressZero();\\n\\n        uint256 owner = s.owners[tokenId];\\n        if (_tokenExists(owner)) revert ERC721ExistingToken(tokenId);\\n        if (_tokenWasBurnt(owner)) revert ERC721BurntToken(tokenId);\\n\\n        s.owners[tokenId] = uint256(uint160(to));\\n\\n        unchecked {\\n            // cannot overflow due to the cost of minting individual tokens\\n            ++s.balances[to];\\n        }\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /// @notice Safely mints a token once.\\n    /// @dev Note: This function implements {ERC721Mintable-safeMint(address,uint256,bytes)}.\\n    /// @dev Note: Either `safeMint` or `safeMintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts with {ERC721MintToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721ExistingToken} if `tokenId` already exists.\\n    /// @dev Reverts with {ERC721BurntToken} if `tokenId` has been previously burnt.\\n    /// @dev Reverts with {ERC721SafeTransferRejected} if `to` is a contract and the call to\\n    ///  {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    /// @param data Optional data to pass along to the receiver call.\\n    function safeMintOnce(Layout storage s, address sender, address to, uint256 tokenId, bytes memory data) internal {\\n        s.mintOnce(to, tokenId);\\n        if (to.hasBytecode()) {\\n            _callOnERC721Received(sender, address(0), to, tokenId, data);\\n        }\\n    }\\n\\n    /// @notice Unsafely mints a batch of tokens once.\\n    /// @dev Note: This function implements {ERC721Mintable-batchMint(address,uint256[])}.\\n    /// @dev Note: Either `batchMint` or `batchMintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts with {ERC721MintToAddressZero} if `to` is the zero address.\\n    /// @dev Reverts with {ERC721ExistingToken} if one of `tokenIds` already exists.\\n    /// @dev Reverts with {ERC721BurntToken} if one of `tokenIds` has been previously burnt.\\n    /// @dev Emits a {Transfer} event from the zero address for each of `tokenIds`.\\n    /// @param to Address of the new tokens owner.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function batchMintOnce(Layout storage s, address to, uint256[] memory tokenIds) internal {\\n        if (to == address(0)) revert ERC721MintToAddressZero();\\n\\n        uint256 length = tokenIds.length;\\n        for (uint256 i; i < length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n            uint256 owner = s.owners[tokenId];\\n            if (_tokenExists(owner)) revert ERC721ExistingToken(tokenId);\\n            if (_tokenWasBurnt(owner)) revert ERC721BurntToken(tokenId);\\n\\n            s.owners[tokenId] = uint256(uint160(to));\\n\\n            emit Transfer(address(0), to, tokenId);\\n        }\\n\\n        unchecked {\\n            s.balances[to] += length;\\n        }\\n    }\\n\\n    /// @notice Unsafely mints tokens to multiple recipients once.\\n    /// @dev Note: This function implements {ERC721Deliverable-deliver(address[],uint256[])}.\\n    /// @dev Note: Either `deliver` or `deliverOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts with {InconsistentArrayLengths} if `recipients` and `tokenIds` have different lengths.\\n    /// @dev Reverts with {ERC721MintToAddressZero} if one of `recipients` is the zero address.\\n    /// @dev Reverts with {ERC721ExistingToken} if one of `tokenIds` already exists.\\n    /// @dev Reverts with {ERC721BurntToken} if one of `tokenIds` has been previously burnt.\\n    /// @dev Emits a {Transfer} event from the zero address for each of `recipients` and `tokenIds`.\\n    /// @param recipients Addresses of the new tokens owners.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function deliverOnce(Layout storage s, address[] memory recipients, uint256[] memory tokenIds) internal {\\n        uint256 length = recipients.length;\\n        if (length != tokenIds.length) revert InconsistentArrayLengths();\\n        for (uint256 i; i < length; ++i) {\\n            address to = recipients[i];\\n            if (to == address(0)) revert ERC721MintToAddressZero();\\n\\n            uint256 tokenId = tokenIds[i];\\n            uint256 owner = s.owners[tokenId];\\n            if (_tokenExists(owner)) revert ERC721ExistingToken(tokenId);\\n            if (_tokenWasBurnt(owner)) revert ERC721BurntToken(tokenId);\\n\\n            s.owners[tokenId] = uint256(uint160(to));\\n            unchecked {\\n                ++s.balances[to];\\n            }\\n\\n            emit Transfer(address(0), to, tokenId);\\n        }\\n    }\\n\\n    /// @notice Burns a token by a sender.\\n    /// @dev Note: This function implements {ERC721Burnable-burnFrom(address,uint256)}.\\n    /// @dev Reverts with {ERC721NonOwnedToken} if `tokenId` is not owned by `from`.\\n    /// @dev Reverts with {ERC721NonApprovedForTransfer} if `sender` is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Emits a {Transfer} event with `to` set to the zero address.\\n    /// @param sender The message sender.\\n    /// @param from The current token owner.\\n    /// @param tokenId The identifier of the token to burn.\\n    function burnFrom(Layout storage s, address sender, address from, uint256 tokenId) internal {\\n        uint256 owner = s.owners[tokenId];\\n        if (!_tokenExists(owner)) revert ERC721NonExistingToken(tokenId);\\n        if (_tokenOwner(owner) != from) revert ERC721NonOwnedToken(from, tokenId);\\n\\n        if (!_isOperatable(s, from, sender)) {\\n            if (!_tokenHasApproval(owner) || sender != s.approvals[tokenId]) revert ERC721NonApprovedForTransfer(sender, from, tokenId);\\n        }\\n\\n        s.owners[tokenId] = BURNT_TOKEN_OWNER_VALUE;\\n\\n        unchecked {\\n            // cannot underflow as balance is verified through TOKEN ownership\\n            --s.balances[from];\\n        }\\n        emit Transfer(from, address(0), tokenId);\\n    }\\n\\n    /// @notice Burns a batch of tokens by a sender.\\n    /// @dev Note: This function implements {ERC721Burnable-batchBurnFrom(address,uint256[])}.\\n    /// @dev Reverts with {ERC721NonOwnedToken} if one of `tokenIds` is not owned by `from`.\\n    /// @dev Reverts with {ERC721NonApprovedForTransfer} if `sender` is not `from` and has not been approved by `from` for each of `tokenIds`.\\n    /// @dev Emits a {Transfer} event with `to` set to the zero address for each of `tokenIds`.\\n    /// @param sender The message sender.\\n    /// @param from The current tokens owner.\\n    /// @param tokenIds The identifiers of the tokens to burn.\\n    function batchBurnFrom(Layout storage s, address sender, address from, uint256[] calldata tokenIds) internal {\\n        bool operatable = _isOperatable(s, from, sender);\\n\\n        uint256 length = tokenIds.length;\\n        for (uint256 i; i < length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n            uint256 owner = s.owners[tokenId];\\n            if (!_tokenExists(owner)) revert ERC721NonExistingToken(tokenId);\\n            if (_tokenOwner(owner) != from) revert ERC721NonOwnedToken(from, tokenId);\\n            if (!operatable) {\\n                if (!_tokenHasApproval(owner) || sender != s.approvals[tokenId]) revert ERC721NonApprovedForTransfer(sender, from, tokenId);\\n            }\\n            s.owners[tokenId] = BURNT_TOKEN_OWNER_VALUE;\\n            emit Transfer(from, address(0), tokenId);\\n        }\\n\\n        if (length != 0) {\\n            unchecked {\\n                s.balances[from] -= length;\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets the balance of an address.\\n    /// @dev Note: This function implements {ERC721-balanceOf(address)}.\\n    /// @dev Reverts with {ERC721BalanceOfAddressZero} if `owner` is the zero address.\\n    /// @param owner The address to query the balance of.\\n    /// @return balance The amount owned by the owner.\\n    function balanceOf(Layout storage s, address owner) internal view returns (uint256 balance) {\\n        if (owner == address(0)) revert ERC721BalanceOfAddressZero();\\n        return s.balances[owner];\\n    }\\n\\n    /// @notice Gets the owner of a token.\\n    /// @dev Note: This function implements {ERC721-ownerOf(uint256)}.\\n    /// @dev Reverts with {ERC721NonExistingToken} if `tokenId` does not exist.\\n    /// @param tokenId The token identifier to query the owner of.\\n    /// @return tokenOwner The owner of the token.\\n    function ownerOf(Layout storage s, uint256 tokenId) internal view returns (address tokenOwner) {\\n        uint256 owner = s.owners[tokenId];\\n        if (!_tokenExists(owner)) revert ERC721NonExistingToken(tokenId);\\n        return _tokenOwner(owner);\\n    }\\n\\n    /// @notice Gets the approved address for a token.\\n    /// @dev Note: This function implements {ERC721-getApproved(uint256)}.\\n    /// @dev Reverts with {ERC721NonExistingToken} if `tokenId` does not exist.\\n    /// @param tokenId The token identifier to query the approval of.\\n    /// @return approved The approved address for the token identifier, or the zero address if no approval is set.\\n    function getApproved(Layout storage s, uint256 tokenId) internal view returns (address approved) {\\n        uint256 owner = s.owners[tokenId];\\n        if (!_tokenExists(owner)) revert ERC721NonExistingToken(tokenId);\\n        if (_tokenHasApproval(owner)) {\\n            return s.approvals[tokenId];\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    /// @notice Gets whether an operator is approved for all tokens by an owner.\\n    /// @dev Note: This function implements {ERC721-isApprovedForAll(address,address)}.\\n    /// @param owner The address which gives the approval for all tokens.\\n    /// @param operator The address which receives the approval for all tokens.\\n    /// @return approvedForAll Whether the operator is approved for all tokens by the owner.\\n    function isApprovedForAll(Layout storage s, address owner, address operator) internal view returns (bool approvedForAll) {\\n        return s.operators[owner][operator];\\n    }\\n\\n    /// @notice Gets whether a token was burnt.\\n    /// @param tokenId The token identifier.\\n    /// @return tokenWasBurnt Whether the token was burnt.\\n    function wasBurnt(Layout storage s, uint256 tokenId) internal view returns (bool tokenWasBurnt) {\\n        return _tokenWasBurnt(s.owners[tokenId]);\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n\\n    /// @notice Calls {IERC721Receiver-onERC721Received} on a target contract.\\n    /// @dev Reverts with {ERC721SafeTransferRejected} if the call to the target fails, reverts or is rejected.\\n    /// @param sender The message sender.\\n    /// @param from Previous token owner.\\n    /// @param to New token owner.\\n    /// @param tokenId Identifier of the token transferred.\\n    /// @param data Optional data to send along with the receiver contract call.\\n    function _callOnERC721Received(address sender, address from, address to, uint256 tokenId, bytes memory data) private {\\n        if (IERC721Receiver(to).onERC721Received(sender, from, tokenId, data) != ERC721_RECEIVED) revert ERC721SafeTransferRejected(to, tokenId);\\n    }\\n\\n    /// @notice Returns whether an account is authorised to make a transfer on behalf of an owner.\\n    /// @param owner The token owner.\\n    /// @param account The account to check the operatability of.\\n    /// @return operatable True if `account` is `owner` or is an operator for `owner`, false otherwise.\\n    function _isOperatable(Layout storage s, address owner, address account) private view returns (bool operatable) {\\n        return (owner == account) || s.operators[owner][account];\\n    }\\n\\n    function _tokenOwner(uint256 owner) private pure returns (address tokenOwner) {\\n        return address(uint160(owner));\\n    }\\n\\n    function _tokenExists(uint256 owner) private pure returns (bool tokenExists) {\\n        return uint160(owner) != 0;\\n    }\\n\\n    function _tokenWasBurnt(uint256 owner) private pure returns (bool tokenWasBurnt) {\\n        return owner == BURNT_TOKEN_OWNER_VALUE;\\n    }\\n\\n    function _tokenHasApproval(uint256 owner) private pure returns (bool tokenHasApproval) {\\n        return owner & TOKEN_APPROVAL_OWNER_FLAG != 0;\\n    }\\n}\\n\",\"keccak256\":\"0xab975e3b8e71ad7bedfa60f5db81f621fe1b0cdad26a48af8dec6b72b9316ddf\",\"license\":\"MIT\"},\"contracts/utils/libraries/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nlibrary Address {\\n    /// @notice Checks if the address is a deployed smart contract.\\n    /// @param addr The address to check.\\n    /// @return hasBytecode True if `addr` is a deployed smart contract, false otherwise.\\n    function hasBytecode(address addr) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size != 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf3119a6298c6da4e7da69344ae8ab51a6a64dc08c68f826a560e72d46cf0ad9c\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a0604052348015600f57600080fd5b50604051610997380380610997833981016040819052602c91603c565b6001600160a01b0316608052606a565b600060208284031215604d57600080fd5b81516001600160a01b0381168114606357600080fd5b9392505050565b60805161090b61008c600039600081816105720152610600015261090b6000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80639da5e8321461003b578063c0b8846814610050575b600080fd5b61004e6100493660046107d2565b610058565b005b61004e610111565b6100937f6d696e7465720000000000000000000000000000000000000000000000000000610084610134565b61008c610143565b9190610177565b61010b848480806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250506040805160208088028281018201909352878252909350879250869182918501908490808284376000920191909152506101049250610207915050565b9190610235565b50505050565b61012a61011c610134565b61012461045d565b9061048b565b6101326104fa565b565b600061013e61052f565b905090565b60008061017160017fc8827d3282af6f37b64c3e9e6f3ac9df286ab0bb0fccd6f8661bf19adb368b23610843565b92915050565b60008281526020848152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915290205460ff16610202576040517f7aa728820000000000000000000000000000000000000000000000000000000081526004810183905273ffffffffffffffffffffffffffffffffffffffff821660248201526044015b60405180910390fd5b505050565b60008061017160017fddf3ee18ae6d688373c219468f8be446e7ae82215f4779d821c7ea5e8c13c0c1610843565b815181518114610271576040517f6582533600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b818110156104565760008482815181106102905761029061087d565b60200260200101519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610300576040517f7851b9cd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008483815181106103145761031461087d565b60209081029190910181015160008181529189905260409091205490915073ffffffffffffffffffffffffffffffffffffffff811615610383576040517f753eceac000000000000000000000000000000000000000000000000000000008152600481018390526024016101f9565b7fdead00000000000000000000000000000000000000000000000000000000000081036103df576040517f31e8d3d5000000000000000000000000000000000000000000000000000000008152600481018390526024016101f9565b60008281526020898152604080832073ffffffffffffffffffffffffffffffffffffffff8716908190558084526001808d019093528184208054909301909255518492907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a4505050806001019050610274565b5050505050565b60008061017160017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104610843565b815473ffffffffffffffffffffffffffffffffffffffff8281169116146104f6576040517f673a31a100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024016101f9565b5050565b6101327f9da5e83200000000000000000000000000000000000000000000000000000000600161052861067c565b91906106aa565b60003332148061053f5750601836105b1561054957503390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1633148061066b57506040517f019a202800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301523360248301523060448301527f0000000000000000000000000000000000000000000000000000000000000000169063019a202890606401602060405180830381865afa158015610647573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061066b91906108ac565b1561067557919050565b3391505090565b60008061017160017fca9d3e17f264b0f3984e2634e94adb37fa3e6a8103f06aeae6fa59e21c769f5e610843565b7c01000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831601610722576040517f72c683bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7fffffffff00000000000000000000000000000000000000000000000000000000919091166000908152602092909252604090912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b60008083601f84011261079857600080fd5b50813567ffffffffffffffff8111156107b057600080fd5b6020830191508360208260051b85010111156107cb57600080fd5b9250929050565b600080600080604085870312156107e857600080fd5b843567ffffffffffffffff8111156107ff57600080fd5b61080b87828801610786565b909550935050602085013567ffffffffffffffff81111561082b57600080fd5b61083787828801610786565b95989497509550505050565b81810381811115610171577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156108be57600080fd5b815180151581146108ce57600080fd5b939250505056fea2646970667358221220311d1e4826405b333da19bd5b85e770bb125bccc4e202fbdf5f75fc5186fa3c764736f6c634300081c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80639da5e8321461003b578063c0b8846814610050575b600080fd5b61004e6100493660046107d2565b610058565b005b61004e610111565b6100937f6d696e7465720000000000000000000000000000000000000000000000000000610084610134565b61008c610143565b9190610177565b61010b848480806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250506040805160208088028281018201909352878252909350879250869182918501908490808284376000920191909152506101049250610207915050565b9190610235565b50505050565b61012a61011c610134565b61012461045d565b9061048b565b6101326104fa565b565b600061013e61052f565b905090565b60008061017160017fc8827d3282af6f37b64c3e9e6f3ac9df286ab0bb0fccd6f8661bf19adb368b23610843565b92915050565b60008281526020848152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915290205460ff16610202576040517f7aa728820000000000000000000000000000000000000000000000000000000081526004810183905273ffffffffffffffffffffffffffffffffffffffff821660248201526044015b60405180910390fd5b505050565b60008061017160017fddf3ee18ae6d688373c219468f8be446e7ae82215f4779d821c7ea5e8c13c0c1610843565b815181518114610271576040517f6582533600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b818110156104565760008482815181106102905761029061087d565b60200260200101519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603610300576040517f7851b9cd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008483815181106103145761031461087d565b60209081029190910181015160008181529189905260409091205490915073ffffffffffffffffffffffffffffffffffffffff811615610383576040517f753eceac000000000000000000000000000000000000000000000000000000008152600481018390526024016101f9565b7fdead00000000000000000000000000000000000000000000000000000000000081036103df576040517f31e8d3d5000000000000000000000000000000000000000000000000000000008152600481018390526024016101f9565b60008281526020898152604080832073ffffffffffffffffffffffffffffffffffffffff8716908190558084526001808d019093528184208054909301909255518492907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a4505050806001019050610274565b5050505050565b60008061017160017fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6104610843565b815473ffffffffffffffffffffffffffffffffffffffff8281169116146104f6576040517f673a31a100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024016101f9565b5050565b6101327f9da5e83200000000000000000000000000000000000000000000000000000000600161052861067c565b91906106aa565b60003332148061053f5750601836105b1561054957503390565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1633148061066b57506040517f019a202800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301523360248301523060448301527f0000000000000000000000000000000000000000000000000000000000000000169063019a202890606401602060405180830381865afa158015610647573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061066b91906108ac565b1561067557919050565b3391505090565b60008061017160017fca9d3e17f264b0f3984e2634e94adb37fa3e6a8103f06aeae6fa59e21c769f5e610843565b7c01000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831601610722576040517f72c683bb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7fffffffff00000000000000000000000000000000000000000000000000000000919091166000908152602092909252604090912080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055565b60008083601f84011261079857600080fd5b50813567ffffffffffffffff8111156107b057600080fd5b6020830191508360208260051b85010111156107cb57600080fd5b9250929050565b600080600080604085870312156107e857600080fd5b843567ffffffffffffffff8111156107ff57600080fd5b61080b87828801610786565b909550935050602085013567ffffffffffffffff81111561082b57600080fd5b61083787828801610786565b95989497509550505050565b81810381811115610171577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156108be57600080fd5b815180151581146108ce57600080fd5b939250505056fea2646970667358221220311d1e4826405b333da19bd5b85e770bb125bccc4e202fbdf5f75fc5186fa3c764736f6c634300081c0033",
  "devdoc": {
    "details": "This contract is to be used as a diamond facet (see ERC2535 Diamond Standard https://eips.ethereum.org/EIPS/eip-2535).Note: This facet depends on {ProxyAdminFacet}, {InterfaceDetectionFacet} and {AccessControlFacet}.",
    "errors": {
      "ERC721BurntToken(uint256)": [
        {
          "params": {
            "tokenId": "The identifier of the token that has been burnt before."
          }
        }
      ],
      "ERC721ExistingToken(uint256)": [
        {
          "params": {
            "tokenId": "The identifier of the token that already exists."
          }
        }
      ],
      "NotProxyAdmin(address)": [
        {
          "params": {
            "account": "The account that was checked."
          }
        }
      ],
      "NotRoleHolder(bytes32,address)": [
        {
          "params": {
            "account": "The account that was checked.",
            "role": "The role the caller is missing."
          }
        }
      ]
    },
    "events": {
      "Transfer(address,address,uint256)": {
        "params": {
          "from": "The previous token owner.",
          "to": "The new token owner.",
          "tokenId": "The transferred token identifier."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "deliver(address[],uint256[])": {
        "details": "Reverts with {NotRoleHolder} if the sender does not have the 'minter' role.Reverts with {ERC721BurntToken} if one of `tokenIds` has been previously burnt.",
        "params": {
          "recipients": "Addresses of the new tokens owners.",
          "tokenIds": "Identifiers of the tokens to mint."
        }
      },
      "initERC721DeliverableOnceStorage()": {
        "details": "Reverts with {NotProxyAdmin} if the sender is not the proxy admin."
      }
    },
    "title": "ERC721 Non-Fungible Token Standard, optional extension: Deliverable (facet version).",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "ERC721BurntToken(uint256)": [
        {
          "notice": "Thrown when minting a token which has been burnt before (MintableOnce implementation)."
        }
      ],
      "ERC721ExistingToken(uint256)": [
        {
          "notice": "Thrown when minting a token that already exists."
        }
      ],
      "ERC721MintToAddressZero()": [
        {
          "notice": "Thrown when minting a token to the zero address."
        }
      ],
      "IllegalInterfaceId()": [
        {
          "notice": "Thrown when setting the illegal interfaceId 0xffffffff."
        }
      ],
      "InconsistentArrayLengths()": [
        {
          "notice": "Thrown when the multiple related arrays have different lengths."
        }
      ],
      "NotProxyAdmin(address)": [
        {
          "notice": "Thrown when an account is not the proxy admin but is required to."
        }
      ],
      "NotRoleHolder(bytes32,address)": [
        {
          "notice": "Thrown when an account does not have the required role."
        }
      ]
    },
    "events": {
      "Transfer(address,address,uint256)": {
        "notice": "Emitted when a token is transferred."
      }
    },
    "kind": "user",
    "methods": {
      "deliver(address[],uint256[])": {
        "notice": "Unsafely mints tokens to multiple recipients."
      },
      "initERC721DeliverableOnceStorage()": {
        "notice": "Marks the following ERC165 interface(s) as supported: ERC721Deliverable."
      }
    },
    "notice": "ERC721Deliverable implementation where burnt tokens cannot be minted again.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}